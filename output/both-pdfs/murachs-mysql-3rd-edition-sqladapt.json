{
  "schemaVersion": "educational-concept-v1",
  "sourceDocId": "murachs-mysql-3rd-edition",
  "sourceFile": "raw_pdf/murachs-mysql-3rd-edition.pdf",
  "generatedAt": "2026-02-27T08:00:11.749119+00:00",
  "concepts": {
    "mysql-intro": {
      "id": "mysql-intro",
      "title": "Introduction to MySQL",
      "definition": "The SELECT statement is used to retrieve data from a database. It allows you to specify which columns and rows to fetch based on certain conditions.",
      "difficulty": "beginner",
      "estimatedReadTime": 1,
      "pageReferences": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p1:c1",
            "murachs-mysql-3rd-edition:p2:c1",
            "murachs-mysql-3rd-edition:p3:c1",
            "murachs-mysql-3rd-edition:p4:c1",
            "murachs-mysql-3rd-edition:p5:c1",
            "murachs-mysql-3rd-edition:p6:c1",
            "murachs-mysql-3rd-edition:p7:c1",
            "murachs-mysql-3rd-edition:p8:c1",
            "murachs-mysql-3rd-edition:p9:c1",
            "murachs-mysql-3rd-edition:p10:c1"
          ],
          "text": "The SELECT statement is used to retrieve data from a database. It allows you to specify which columns and rows to fetch based on certain conditions."
        },
        "explanation": {
          "chunkIds": [],
          "text": "The SELECT statement is one of the most fundamental tools in SQL, allowing developers to extract specific information from a database. It works by specifying the columns you want to retrieve and optionally filtering the data with WHERE clauses. This statement is crucial for querying databases and retrieving the necessary data for applications. Understanding how to use SELECT effectively can greatly enhance your ability to interact with and manipulate data in MySQL."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p11:c1",
            "murachs-mysql-3rd-edition:p12:c1",
            "murachs-mysql-3rd-edition:p13:c1",
            "murachs-mysql-3rd-edition:p14:c1",
            "murachs-mysql-3rd-edition:p15:c1",
            "murachs-mysql-3rd-edition:p16:c1",
            "murachs-mysql-3rd-edition:p17:c1",
            "murachs-mysql-3rd-edition:p18:c1",
            "murachs-mysql-3rd-edition:p19:c1",
            "murachs-mysql-3rd-edition:p20:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- Selecting specific columns FROM a TABLE SELECT name, age FROM users;",
              "explanation": "This example demonstrates how to select the 'name' and 'age' columns from the 'users' table. It retrieves all rows in the table.",
              "validation_note": "SQL auto-fixed: "
            },
            {
              "title": "Practical Example",
              "code": "-- Selecting data with a condition\nSELECT name FROM users WHERE age > 18;",
              "explanation": "This practical example shows how to select only the names of users who are older than 18 years. It uses a WHERE clause to filter the results based on the 'age' column."
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p21:c1",
            "murachs-mysql-3rd-edition:p22:c1",
            "murachs-mysql-3rd-edition:p23:c1",
            "murachs-mysql-3rd-edition:p24:c1",
            "murachs-mysql-3rd-edition:p25:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting to specify columns",
              "incorrect_code": "-- Incorrect: SELECT FROM users;",
              "correct_code": "-- Correct: SELECT * FROM users;",
              "explanation": "This mistake occurs when a developer tries to run a SELECT statement without specifying any columns. This will result in an error because SQL needs to know which data to retrieve."
            },
            {
              "mistake": "Using incorrect column names",
              "incorrect_code": "-- Incorrect: SELECT name, age FROM users WHERE email = 'test@example.com';",
              "correct_code": "-- Correct: SELECT name, age FROM users WHERE email = 'test@example.com';",
              "explanation": "This mistake happens when a developer specifies a column that does not exist in the table. It's crucial to double-check column names and ensure they match exactly with those in the database schema."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Write a SELECT statement to retrieve the 'product_name' and 'price' from the 'products' table where the 'category' is 'Electronics'.",
            "solution": "SELECT product_name, price FROM products WHERE category = 'Electronics';\nThis query will return the names and prices of all products in the 'Electronics' category."
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "relational-databases-murach": {
      "id": "relational-databases-murach",
      "title": "Relational Databases",
      "definition": "A relational database is a collection of related tables that store data in rows and columns. It uses SQL (Structured Query Language) to manage and manipulate this data.",
      "difficulty": "beginner",
      "estimatedReadTime": 1,
      "pageReferences": [
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p21:c1",
            "murachs-mysql-3rd-edition:p22:c1",
            "murachs-mysql-3rd-edition:p23:c1",
            "murachs-mysql-3rd-edition:p24:c1",
            "murachs-mysql-3rd-edition:p25:c1",
            "murachs-mysql-3rd-edition:p26:c1",
            "murachs-mysql-3rd-edition:p27:c1"
          ],
          "text": "A relational database is a collection of related tables that store data in rows and columns. It uses SQL (Structured Query Language) to manage and manipulate this data."
        },
        "explanation": {
          "chunkIds": [],
          "text": "Relational databases are essential for organizing and retrieving information efficiently. They solve the problem of managing large amounts of data by breaking it into smaller, manageable pieces called tables. Each table has a unique structure with specific columns and rows. SQL is used to interact with these tables, allowing you to query, insert, update, and delete data. Understanding relational databases is crucial for anyone working with data in a structured format."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p28:c1",
            "murachs-mysql-3rd-edition:p29:c1",
            "murachs-mysql-3rd-edition:p30:c1",
            "murachs-mysql-3rd-edition:p31:c1",
            "murachs-mysql-3rd-edition:p32:c1",
            "murachs-mysql-3rd-edition:p33:c1",
            "murachs-mysql-3rd-edition:p34:c1",
            "murachs-mysql-3rd-edition:p35:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- SELECT all columns FROM a TABLE SELECT * FROM employees;",
              "explanation": "This example demonstrates how to retrieve all data from an 'employees' table. The asterisk (*) is a wildcard that selects all columns.",
              "validation_note": "SQL auto-fixed: "
            },
            {
              "title": "Practical Example",
              "code": "-- Retrieve specific information based on a condition\nSELECT name, salary FROM employees WHERE department = 'Sales';",
              "explanation": "This practical example shows how to query the 'employees' table for names and salaries of those in the Sales department."
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p36:c1",
            "murachs-mysql-3rd-edition:p37:c1",
            "murachs-mysql-3rd-edition:p38:c1",
            "murachs-mysql-3rd-edition:p39:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting to specify a column name or using an asterisk without context",
              "incorrect_code": "-- Incorrect usage\nSELECT FROM employees;",
              "correct_code": "-- Correct usage\nSELECT * FROM employees;",
              "explanation": "Always specify the columns you need. Using an asterisk is fine if you want all columns, but it's better to be specific for clarity and performance."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Create a table named 'students' with columns for id (integer), name (varchar), and age (integer). Insert two students into the table. Then, write a query to retrieve all student names.",
            "solution": "-- Create the table\nCREATE TABLE students (\n  id INT PRIMARY KEY,\n  name VARCHAR(100),\n  age INT\n);\n-- Insert data\nINSERT INTO students (id, name, age) VALUES (1, 'Alice', 20);\nINSERT INTO students (id, name, age) VALUES (2, 'Bob', 22);\n-- Query for names\nSELECT name FROM students;"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "select-statement-murach": {
      "id": "select-statement-murach",
      "title": "SELECT Statement",
      "definition": "A SELECT statement is used to retrieve data from a database table. It allows you to specify which columns and rows of data you want to see.",
      "difficulty": "beginner",
      "estimatedReadTime": 1,
      "pageReferences": [
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p73:c1",
            "murachs-mysql-3rd-edition:p74:c1",
            "murachs-mysql-3rd-edition:p75:c1",
            "murachs-mysql-3rd-edition:p76:c1",
            "murachs-mysql-3rd-edition:p77:c1",
            "murachs-mysql-3rd-edition:p78:c1"
          ],
          "text": "A SELECT statement is used to retrieve data from a database table. It allows you to specify which columns and rows of data you want to see."
        },
        "explanation": {
          "chunkIds": [],
          "text": "The SELECT statement is one of the most fundamental tools in SQL for querying databases. It enables users to extract specific information from tables based on certain conditions. Hereâ€™s how it works:\n1. **Specify Columns**: You list the column names you want to retrieve, separated by commas.\n2. **FROM Table**: This specifies the table from which to fetch the data.\n3. **WHERE Condition (Optional)**: This filters the rows that are returned based on a condition.\n4. **ORDER BY Clause (Optional)**: This sorts the results in ascending or descending order based on one or more columns.\nYou use SELECT statements whenever you need to view, analyze, or manipulate data stored in your database."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p79:c1",
            "murachs-mysql-3rd-edition:p80:c1",
            "murachs-mysql-3rd-edition:p81:c1",
            "murachs-mysql-3rd-edition:p82:c1",
            "murachs-mysql-3rd-edition:p83:c1",
            "murachs-mysql-3rd-edition:p84:c1",
            "murachs-mysql-3rd-edition:p85:c1",
            "murachs-mysql-3rd-edition:p86:c1",
            "murachs-mysql-3rd-edition:p87:c1",
            "murachs-mysql-3rd-edition:p88:c1",
            "murachs-mysql-3rd-edition:p89:c1",
            "murachs-mysql-3rd-edition:p90:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "SELECT vendor_name, vendor_address1, vendor_state FROM vendors;",
              "explanation": "This example retrieves the names and addresses of all vendors in the database."
            },
            {
              "title": "Practical Example",
              "code": "SELECT vendor_name, vendor_phone FROM vendors WHERE vendor_state = 'CA';",
              "explanation": "This practical example fetches the names and phone numbers of vendors located in California."
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p91:c1",
            "murachs-mysql-3rd-edition:p92:c1",
            "murachs-mysql-3rd-edition:p93:c1",
            "murachs-mysql-3rd-edition:p94:c1",
            "murachs-mysql-3rd-edition:p95:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting to specify columns",
              "incorrect_code": "SELECT FROM vendors;",
              "correct_code": "SELECT vendor_name FROM vendors;",
              "explanation": "Always include column names after SELECT. If you omit them, the query will return all columns."
            },
            {
              "mistake": "Using incorrect syntax for WHERE clause",
              "incorrect_code": "SELECT vendor_name FROM vendors WHERE vendor_state = 'CA';",
              "correct_code": "SELECT vendor_name FROM vendors WHERE vendor_state = 'CA';",
              "explanation": "Ensure that the condition in the WHERE clause is correctly formatted. SQL is case-sensitive, so make sure keywords and column names match exactly."
            },
            {
              "mistake": "Not ordering results",
              "incorrect_code": "SELECT vendor_name FROM vendors;",
              "correct_code": "SELECT vendor_name FROM vendors ORDER BY vendor_state;",
              "explanation": "Ordering your results can help you analyze data more effectively. Always consider sorting if the order of results matters."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Write a SELECT statement to retrieve the names and email addresses of all customers from the 'customers' table who are located in New York City.",
            "solution": "SELECT customer_name, email FROM customers WHERE city = 'New York';\nThis query will return the names and emails of all customers living in New York City."
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "where-clause-murach": {
      "id": "where-clause-murach",
      "title": "WHERE Clause",
      "definition": "The WHERE clause is used in SQL to filter records and only return those that meet certain conditions.",
      "difficulty": "beginner",
      "estimatedReadTime": 1,
      "pageReferences": [
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p85:c1",
            "murachs-mysql-3rd-edition:p86:c1",
            "murachs-mysql-3rd-edition:p87:c1",
            "murachs-mysql-3rd-edition:p88:c1",
            "murachs-mysql-3rd-edition:p89:c1",
            "murachs-mysql-3rd-edition:p90:c1",
            "murachs-mysql-3rd-edition:p91:c1"
          ],
          "text": "The WHERE clause is used in SQL to filter records and only return those that meet certain conditions."
        },
        "explanation": {
          "chunkIds": [],
          "text": "The WHERE clause is essential for narrowing down data in a database. It allows you to specify conditions that rows must meet to be included in the result set. For example, if you want to find all customers who live in New York City, you would use the WHERE clause to filter out only those records where the city column equals 'New York City'. This is crucial for retrieving specific data efficiently and avoiding unnecessary processing of large datasets."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p92:c1",
            "murachs-mysql-3rd-edition:p93:c1",
            "murachs-mysql-3rd-edition:p94:c1",
            "murachs-mysql-3rd-edition:p95:c1",
            "murachs-mysql-3rd-edition:p96:c1",
            "murachs-mysql-3rd-edition:p97:c1",
            "murachs-mysql-3rd-edition:p98:c1",
            "murachs-mysql-3rd-edition:p99:c1",
            "murachs-mysql-3rd-edition:p100:c1",
            "murachs-mysql-3rd-edition:p101:c1",
            "murachs-mysql-3rd-edition:p102:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- SELECT all customers FROM New York City SELECT * FROM customers WHERE city = 'New York City';",
              "explanation": "This example selects all columns (indicated by *) from the 'customers' table where the 'city' column equals 'New York City'.",
              "validation_note": "SQL auto-fixed: "
            },
            {
              "title": "Practical Example",
              "code": "-- Find employees who earn more than $50,000\nSELECT name, salary FROM employees WHERE salary > 50000;",
              "explanation": "This practical example retrieves the 'name' and 'salary' of all employees whose salary is greater than $50,000."
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p103:c1",
            "murachs-mysql-3rd-edition:p104:c1",
            "murachs-mysql-3rd-edition:p105:c1",
            "murachs-mysql-3rd-edition:p106:c1",
            "murachs-mysql-3rd-edition:p107:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting to include a semicolon at the end of the condition",
              "incorrect_code": "-- Incorrect: No semicolon\nSELECT * FROM customers WHERE city = 'New York City'",
              "correct_code": "-- Correct: Semicolon included\nSELECT * FROM customers WHERE city = 'New York City';",
              "explanation": "SQL statements must end with a semicolon to indicate the end of the command. Forgetting it can lead to syntax errors."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Write a SQL query that selects all products from the 'products' table where the price is less than $100 and the category is 'Electronics'.",
            "solution": "-- Solution: Selecting products based on multiple conditions\nSELECT * FROM products WHERE price < 100 AND category = 'Electronics';\nExplanation: This query filters the 'products' table to return only those rows where both the 'price' column is less than $100 and the 'category' column equals 'Electronics'."
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "order-by-murach": {
      "id": "order-by-murach",
      "title": "ORDER BY Clause",
      "definition": "The ORDER BY clause is used to sort the results of a query in ascending or descending order based on one or more columns.",
      "difficulty": "beginner",
      "estimatedReadTime": 1,
      "pageReferences": [
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p101:c1",
            "murachs-mysql-3rd-edition:p102:c1",
            "murachs-mysql-3rd-edition:p103:c1"
          ],
          "text": "The ORDER BY clause is used to sort the results of a query in ascending or descending order based on one or more columns."
        },
        "explanation": {
          "chunkIds": [],
          "text": "The ORDER BY clause is essential for organizing data in a meaningful way after retrieving it from a database. It allows you to control the sequence in which rows are displayed, making it easier to analyze and understand the data. By default, ORDER BY sorts data in ascending order (A-Z, 0-9). However, you can specify descending order by using the DESC keyword."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p104:c1",
            "murachs-mysql-3rd-edition:p105:c1",
            "murachs-mysql-3rd-edition:p106:c1",
            "murachs-mysql-3rd-edition:p107:c1",
            "murachs-mysql-3rd-edition:p108:c1",
            "murachs-mysql-3rd-edition:p109:c1",
            "murachs-mysql-3rd-edition:p110:c1",
            "murachs-mysql-3rd-edition:p111:c1",
            "murachs-mysql-3rd-edition:p112:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "SELECT invoice_number, invoice_date FROM invoices ORDER BY invoice_date;",
              "explanation": "This example sorts all invoices by their date in ascending order. The result will show the oldest invoices first."
            },
            {
              "title": "Practical Example",
              "code": "SELECT product_name, price FROM products ORDER BY price DESC LIMIT 5;",
              "explanation": "This practical example retrieves the top 5 most expensive products by sorting them in descending order based on their prices. This helps quickly identify the highest-priced items."
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p113:c1",
            "murachs-mysql-3rd-edition:p114:c1",
            "murachs-mysql-3rd-edition:p115:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting to specify column names",
              "incorrect_code": "SELECT invoice_number, invoice_date FROM invoices ORDER BY;",
              "correct_code": "SELECT invoice_number, invoice_date FROM invoices ORDER BY invoice_date;",
              "explanation": "This mistake occurs when the ORDER BY clause is used without specifying any columns. It results in an error because MySQL doesn't know what to sort by."
            },
            {
              "mistake": "Using DESC for ascending order",
              "incorrect_code": "SELECT product_name, price FROM products ORDER BY price DESC;",
              "correct_code": "SELECT product_name, price FROM products ORDER BY price ASC;",
              "explanation": "This mistake happens when the DESC keyword is used instead of ASC to sort in ascending order. It results in the data being sorted in descending order."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Write a SQL query that retrieves all employees from the 'employees' table, sorted by their hire date in descending order.",
            "solution": "SELECT employee_name, hire_date FROM employees ORDER BY hire_date DESC;"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "joins-murach": {
      "id": "joins-murach",
      "title": "Joining Tables",
      "definition": "Joining tables is a method used in database management to combine rows from two or more tables based on a related column between them. It's essential for retrieving data that spans multiple tables and allows for complex queries.",
      "difficulty": "intermediate",
      "estimatedReadTime": 1,
      "pageReferences": [
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        139,
        140,
        141,
        142
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p117:c1",
            "murachs-mysql-3rd-edition:p118:c1",
            "murachs-mysql-3rd-edition:p119:c1",
            "murachs-mysql-3rd-edition:p120:c1",
            "murachs-mysql-3rd-edition:p121:c1",
            "murachs-mysql-3rd-edition:p122:c1"
          ],
          "text": "Joining tables is a method used in database management to combine rows from two or more tables based on a related column between them. It's essential for retrieving data that spans multiple tables and allows for complex queries."
        },
        "explanation": {
          "chunkIds": [],
          "text": "Imagine you have two tables: one with customer information (Customers) and another with their order details (Orders). If you want to find all orders made by a specific customer, you'd need to join these tables based on the customer's ID. This concept is crucial because it enables you to access comprehensive data that might be distributed across different tables in your database."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p123:c1",
            "murachs-mysql-3rd-edition:p124:c1",
            "murachs-mysql-3rd-edition:p125:c1",
            "murachs-mysql-3rd-edition:p126:c1",
            "murachs-mysql-3rd-edition:p127:c1",
            "murachs-mysql-3rd-edition:p128:c1",
            "murachs-mysql-3rd-edition:p129:c1",
            "murachs-mysql-3rd-edition:p130:c1",
            "murachs-mysql-3rd-edition:p131:c1",
            "murachs-mysql-3rd-edition:p132:c1",
            "murachs-mysql-3rd-edition:p133:c1",
            "murachs-mysql-3rd-edition:p134:c1"
          ],
          "items": [
            {
              "title": "Basic INNER JOIN",
              "code": "-- Selecting customer names and their order IDs\nSELECT Customers.customer_name, Orders.order_id\nFROM Customers\nINNER JOIN Orders ON Customers.customer_id = Orders.customer_id;",
              "explanation": "This example demonstrates how to join two tables using an INNER JOIN. It retrieves the names of customers who have placed orders."
            },
            {
              "title": "Practical Example: Finding All Orders by a Specific Customer",
              "code": "-- Selecting all orders for customer 'John Doe' SELECT * FROM Orders WHERE customer_id = (SELECT customer_id FROM Customers WHERE customer_name = 'John Doe');",
              "explanation": "This practical example shows how to combine a join with a subquery to find all orders made by a specific customer.",
              "validation_note": "SQL auto-fixed: "
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p135:c1",
            "murachs-mysql-3rd-edition:p136:c1",
            "murachs-mysql-3rd-edition:p137:c1",
            "murachs-mysql-3rd-edition:p138:c1",
            "murachs-mysql-3rd-edition:p139:c1"
          ],
          "items": [
            {
              "mistake": "Using the wrong type of join",
              "incorrect_code": "-- Incorrectly using LEFT JOIN instead of INNER JOIN\nSELECT * FROM Customers\nLEFT JOIN Orders ON Customers.customer_id = Orders.customer_id;",
              "correct_code": "-- Correct usage of INNER JOIN\nSELECT * FROM Customers\nINNER JOIN Orders ON Customers.customer_id = Orders.customer_id;",
              "explanation": "This mistake occurs when the type of join used does not match the desired outcome. Always choose the appropriate join type based on your query requirements."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Create a query that retrieves all employees who have worked on projects in the 'Technology' department.",
            "solution": "SELECT Employees.employee_name FROM Employees\nINNER JOIN Employee_Projects ON Employees.employee_id = Employee_Projects.employee_id\nINNER JOIN Projects ON Employee_Projects.project_id = Projects.project_id\nWHERE Projects.department = 'Technology';"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "inner-join-murach": {
      "id": "inner-join-murach",
      "title": "Inner Join",
      "definition": "An Inner Join is a type of join operation that returns rows from two tables where there is a match between their common columns. It's essential for combining data from multiple tables based on related information.",
      "difficulty": "beginner",
      "estimatedReadTime": 1,
      "pageReferences": [
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        127,
        128
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p117:c1",
            "murachs-mysql-3rd-edition:p118:c1",
            "murachs-mysql-3rd-edition:p119:c1",
            "murachs-mysql-3rd-edition:p120:c1"
          ],
          "text": "An Inner Join is a type of join operation that returns rows from two tables where there is a match between their common columns. It's essential for combining data from multiple tables based on related information."
        },
        "explanation": {
          "chunkIds": [],
          "text": "Imagine you have two tables: one with vendor details (VendorID, VendorName) and another with invoice details (InvoiceID, VendorID, InvoiceDate). An Inner Join allows you to combine these tables so that you can see the vendor name along with their invoices. This is particularly useful when you need to analyze data from multiple sources that are related through a common attribute."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p121:c1",
            "murachs-mysql-3rd-edition:p122:c1",
            "murachs-mysql-3rd-edition:p123:c1",
            "murachs-mysql-3rd-edition:p124:c1",
            "murachs-mysql-3rd-edition:p125:c1",
            "murachs-mysql-3rd-edition:p126:c1",
            "murachs-mysql-3rd-edition:p127:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- Joining two tables on a common column\nSELECT V.VendorName, I.InvoiceDate\nFROM Vendors AS V\nINNER JOIN Invoices AS I ON V.VendorID = I.VendorID;",
              "explanation": "This example joins the Vendors and Invoices tables based on the VendorID column. It returns the vendor name and invoice date for each matching record."
            },
            {
              "title": "Practical Example",
              "code": "-- Finding all invoices FROM a specific vendor SELECT I.InvoiceID, I.InvoiceDate FROM Invoices AS I INNER JOIN Vendors AS V ON I.VendorID = V.VendorID WHERE V.VendorName = 'ABC Corp';",
              "explanation": "This practical example demonstrates how to find all invoices for a specific vendor by joining the Invoices and Vendors tables and filtering by the vendor name.",
              "validation_note": "SQL auto-fixed: "
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p128:c1"
          ],
          "items": [
            {
              "mistake": "Using the wrong column names in the join condition",
              "incorrect_code": "-- Incorrect join condition\nSELECT V.VendorName, I.InvoiceDate\nFROM Vendors AS V\nINNER JOIN Invoices AS I ON V.VendorID = I.CustomerID;",
              "correct_code": "-- Correct join condition\nSELECT V.VendorName, I.InvoiceDate\nFROM Vendors AS V\nINNER JOIN Invoices AS I ON V.VendorID = I.VendorID;",
              "explanation": "This mistake occurs when the column names used in the join condition do not match between tables. Always double-check that you're using the correct column names."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Write an SQL query to find all customers who have made at least one order from a specific vendor, given the VendorID of the vendor.",
            "solution": "-- Solution\nSELECT C.CustomerName\nFROM Customers AS C\nINNER JOIN Orders AS O ON C.CustomerID = O.CustomerID\nWHERE O.VendorID = 123;"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "outer-join-murach": {
      "id": "outer-join-murach",
      "title": "Outer Join",
      "definition": "An outer join is a type of SQL join that returns all records from both tables, even if there are no matching rows between them. This is useful for retrieving data from multiple tables where you want to ensure all records from both tables are included in the result set.",
      "difficulty": "intermediate",
      "estimatedReadTime": 1,
      "pageReferences": [
        129,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        139,
        140,
        141,
        142,
        143,
        144
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p129:c1",
            "murachs-mysql-3rd-edition:p130:c1",
            "murachs-mysql-3rd-edition:p131:c1",
            "murachs-mysql-3rd-edition:p132:c1",
            "murachs-mysql-3rd-edition:p133:c1"
          ],
          "text": "An outer join is a type of SQL join that returns all records from both tables, even if there are no matching rows between them. This is useful for retrieving data from multiple tables where you want to ensure all records from both tables are included in the result set."
        },
        "explanation": {
          "chunkIds": [],
          "text": "Outer joins solve the problem of missing data when using inner joins. An inner join only returns rows where there is a match in both tables, which can lead to incomplete results if some records don't have corresponding entries in the other table. Outer joins include all records from both tables, filling in NULL values for non-matching rows. This ensures that no data is lost and provides a complete picture of the data across multiple tables."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p134:c1",
            "murachs-mysql-3rd-edition:p135:c1",
            "murachs-mysql-3rd-edition:p136:c1",
            "murachs-mysql-3rd-edition:p137:c1",
            "murachs-mysql-3rd-edition:p138:c1",
            "murachs-mysql-3rd-edition:p139:c1",
            "murachs-mysql-3rd-edition:p140:c1",
            "murachs-mysql-3rd-edition:p141:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- Basic LEFT JOIN example\nSELECT employees.employee_id, departments.department_name\nFROM employees\nLEFT JOIN departments ON employees.department_id = departments.department_id;",
              "explanation": "This query retrieves all employee records and their corresponding department names. If an employee does not have a department (NULL in the department_id), it will still include that employee's record with NULL for the department name."
            },
            {
              "title": "Practical Example",
              "code": "-- Practical scenario: Finding customers who have never made a purchase\nSELECT customers.customer_id, customers.customer_name\nFROM customers\nLEFT JOIN orders ON customers.customer_id = orders.customer_id\nWHERE orders.order_id IS NULL;",
              "explanation": "This query identifies all customers who have not placed any orders. It uses a LEFT JOIN to include all customer records and only those that do not have a matching order (NULL in the order_id) are returned."
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p142:c1",
            "murachs-mysql-3rd-edition:p143:c1",
            "murachs-mysql-3rd-edition:p144:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting to specify columns",
              "incorrect_code": "-- Incorrect: No column specified\nSELECT * FROM employees LEFT JOIN departments ON employees.department_id = departments.department_id;",
              "correct_code": "-- Correct: Specify columns explicitly\nSELECT employees.employee_id, departments.department_name FROM employees LEFT JOIN departments ON employees.department_id = departments.department_id;",
              "explanation": "Always specify the columns you want to retrieve. Using '*' can lead to unexpected results and is generally not recommended."
            },
            {
              "mistake": "Using INNER JOIN instead of OUTER JOIN",
              "incorrect_code": "-- Incorrect: Using INNER JOIN\nSELECT employees.employee_id, departments.department_name FROM employees INNER JOIN departments ON employees.department_id = departments.department_id;",
              "correct_code": "-- Correct: Use LEFT JOIN to include all records FROM both tables SELECT employees.employee_id, departments.department_name FROM employees LEFT JOIN departments ON employees.department_id = departments.department_id;",
              "explanation": "Outer joins are necessary when you want to ensure all records from both tables are included. Using an inner join will exclude non-matching records."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Write a query that retrieves all products and their corresponding suppliers, including those without suppliers.",
            "solution": "-- Solution\nSELECT products.product_id, products.product_name, suppliers.supplier_name FROM products LEFT JOIN suppliers ON products.supplier_id = suppliers.supplier_id;"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "insert-murach": {
      "id": "insert-murach",
      "title": "INSERT Statement",
      "definition": "An outer join is a type of SQL query that retrieves rows from two or more tables based on a related column between them. It returns all records when there is a match in either left or right table, and null values for unmatched rows.",
      "difficulty": "beginner",
      "estimatedReadTime": 1,
      "pageReferences": [
        149,
        150,
        151,
        152,
        153,
        154,
        155,
        156,
        157,
        158,
        159,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p149:c1",
            "murachs-mysql-3rd-edition:p150:c1",
            "murachs-mysql-3rd-edition:p151:c1",
            "murachs-mysql-3rd-edition:p152:c1"
          ],
          "text": "An outer join is a type of SQL query that retrieves rows from two or more tables based on a related column between them. It returns all records when there is a match in either left or right table, and null values for unmatched rows."
        },
        "explanation": {
          "chunkIds": [],
          "text": "Outer joins are essential when you need to ensure that no data is lost due to missing matches between tables. For example, if you have two tables: one with vendor information and another with their invoices, an outer join will return all vendors, even those without any invoices, filling in null values for the invoice details."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p153:c1",
            "murachs-mysql-3rd-edition:p154:c1",
            "murachs-mysql-3rd-edition:p155:c1",
            "murachs-mysql-3rd-edition:p156:c1",
            "murachs-mysql-3rd-edition:p157:c1",
            "murachs-mysql-3rd-edition:p158:c1",
            "murachs-mysql-3rd-edition:p159:c1",
            "murachs-mysql-3rd-edition:p160:c1",
            "murachs-mysql-3rd-edition:p161:c1",
            "murachs-mysql-3rd-edition:p162:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "SELECT vendor_name, invoice_number, invoice_total FROM vendors LEFT JOIN invoices ON vendors.vendor_id = invoices.vendor_id;",
              "explanation": "This query retrieves all vendors and their corresponding invoices. If a vendor has no invoices, the invoice details will be null."
            },
            {
              "title": "Practical Example",
              "code": "SELECT department_name, last_name, project_number FROM departments LEFT JOIN employees ON departments.department_number = employees.department_number LEFT JOIN projects ON employees.employee_id = projects.employee_id;",
              "explanation": "This query combines three tables to show all departments, their employees, and the projects they are assigned to. Unmatched rows will have null values for missing data."
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p163:c1",
            "murachs-mysql-3rd-edition:p164:c1",
            "murachs-mysql-3rd-edition:p165:c1",
            "murachs-mysql-3rd-edition:p166:c1"
          ],
          "items": [
            {
              "mistake": "Using RIGHT JOIN instead of LEFT JOIN",
              "incorrect_code": "SELECT department_name, last_name FROM departments RIGHT JOIN employees ON departments.department_number = employees.department_number;",
              "correct_code": "SELECT department_name, last_name FROM departments LEFT JOIN employees ON departments.department_number = employees.department_number;",
              "explanation": "Students often mistakenly use RIGHT JOIN when they should be using LEFT JOIN to ensure all rows from the left table are included."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Write a query that retrieves all customers and their orders, including those with no orders. Assume you have two tables: 'customers' and 'orders'.",
            "solution": "SELECT customer_name, order_id FROM customers LEFT JOIN orders ON customers.customer_id = orders.customer_id; This query will return all customers, even if they don't have any orders, filling in null values for the order details."
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "update-murach": {
      "id": "update-murach",
      "title": "UPDATE Statement",
      "definition": "The UPDATE statement is used to modify existing records in a database table. It allows you to change data without having to delete and recreate rows.",
      "difficulty": "beginner",
      "estimatedReadTime": 1,
      "pageReferences": [
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174,
        175,
        176,
        177,
        178,
        179,
        180
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p165:c1",
            "murachs-mysql-3rd-edition:p166:c1",
            "murachs-mysql-3rd-edition:p167:c1",
            "murachs-mysql-3rd-edition:p168:c1"
          ],
          "text": "The UPDATE statement is used to modify existing records in a database table. It allows you to change data without having to delete and recreate rows."
        },
        "explanation": {
          "chunkIds": [],
          "text": "The UPDATE statement solves the problem of needing to change data in an existing table without losing any other information. Here's how it works:\n1. You specify which table you want to update.\n2. You define a condition that identifies which rows should be updated.\n3. You set new values for one or more columns in those rows.\n\nFor example, if you have a 'students' table and you need to change the grade of a student with ID 101, you would use an UPDATE statement like this:\nUPDATE students SET grade = 'A' WHERE student_id = 101;\nThis changes only the grade for that specific student without affecting any other data in the table.\n\nYou should use the UPDATE statement when you need to make changes to existing records. Be careful not to update too many rows at once, as this can be time-consuming and may cause unintended side effects."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p169:c1",
            "murachs-mysql-3rd-edition:p170:c1",
            "murachs-mysql-3rd-edition:p171:c1",
            "murachs-mysql-3rd-edition:p172:c1",
            "murachs-mysql-3rd-edition:p173:c1",
            "murachs-mysql-3rd-edition:p174:c1",
            "murachs-mysql-3rd-edition:p175:c1",
            "murachs-mysql-3rd-edition:p176:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "UPDATE employees SET salary = salary * 1.10 WHERE department_id = 5;",
              "explanation": "This example updates the salary of all employees in department 5 by increasing it by 10%. The WHERE clause ensures that only relevant rows are affected.",
              "validation_note": "SQL auto-fixed: "
            },
            {
              "title": "Practical Example",
              "code": "UPDATE inventory SET stock_level = stock_level - 1 WHERE product_id = 'P1234';",
              "explanation": "In a real-world scenario, this might be used to decrease the stock level of a specific product after it has been sold. The WHERE clause ensures that only the correct product is updated.",
              "validation_note": "SQL auto-fixed: "
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p177:c1",
            "murachs-mysql-3rd-edition:p178:c1",
            "murachs-mysql-3rd-edition:p179:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting the WHERE clause",
              "incorrect_code": "UPDATE employees SET salary = salary * 1.10;",
              "correct_code": "UPDATE employees SET salary = salary * 1.10 WHERE department_id = 5;",
              "explanation": "This mistake updates all rows in the table, which is usually not intended. Always include a WHERE clause to specify which rows should be updated."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Write an UPDATE statement that increases the price of all products in category 'Electronics' by 5%. Use a transaction to ensure data integrity.",
            "solution": "BEGIN TRANSACTION;\nUPDATE products SET price = price * 1.05 WHERE category = 'Electronics';\nCOMMIT;"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "delete-murach": {
      "id": "delete-murach",
      "title": "DELETE Statement",
      "definition": "The DELETE statement is used to remove rows from a table based on a specified condition.",
      "difficulty": "beginner",
      "estimatedReadTime": 1,
      "pageReferences": [
        177,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        187,
        188
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p177:c1",
            "murachs-mysql-3rd-edition:p178:c1",
            "murachs-mysql-3rd-edition:p179:c1"
          ],
          "text": "The DELETE statement is used to remove rows from a table based on a specified condition."
        },
        "explanation": {
          "chunkIds": [],
          "text": "The DELETE statement is essential for managing data integrity and cleaning up unnecessary records. It allows you to specify exactly which rows should be removed, ensuring that only the intended data is deleted. This is particularly useful in maintaining accurate and up-to-date databases."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p180:c1",
            "murachs-mysql-3rd-edition:p181:c1",
            "murachs-mysql-3rd-edition:p182:c1",
            "murachs-mysql-3rd-edition:p183:c1",
            "murachs-mysql-3rd-edition:p184:c1",
            "murachs-mysql-3rd-edition:p185:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- DELETE a single row FROM the 'employees' TABLE WHERE the employee ID is 101 DELETE FROM employees WHERE employee_id = 101;",
              "explanation": "This example demonstrates how to delete a specific row based on its unique identifier.",
              "validation_note": "SQL auto-fixed: "
            },
            {
              "title": "Practical Example",
              "code": "-- DELETE all records FROM the 'temp_data' TABLE WHERE the date is older than one year DELETE FROM temp_data WHERE date_column < DATE_SUB(CURDATE(), INTERVAL 1 YEAR);",
              "explanation": "This practical example shows how DELETE can be used to clean up old data that's no longer needed.",
              "validation_note": "SQL auto-fixed: "
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p186:c1",
            "murachs-mysql-3rd-edition:p187:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting the WHERE clause",
              "incorrect_code": "-- Incorrectly deletes all rows FROM 'employees' DELETE FROM employees;",
              "correct_code": "-- Correctly deletes a specific row\nDELETE FROM employees WHERE employee_id = 101;",
              "explanation": "This mistake can result in accidental deletion of all data in the table. Always include the WHERE clause to target specific rows."
            },
            {
              "mistake": "Using wildcards without caution",
              "incorrect_code": "-- Incorrectly deletes multiple rows due to wildcard usage\nDELETE FROM employees WHERE department LIKE '%Sales%';",
              "correct_code": "-- Correctly deletes a single row using an exact match\nDELETE FROM employees WHERE employee_id = 101;",
              "explanation": "Wildcards can lead to unintended deletions if not used carefully. Always ensure that your conditions are specific enough."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Write a DELETE statement to remove all records from the 'logs' table where the log level is 'DEBUG'.",
            "solution": "-- Correct solution\nDELETE FROM logs WHERE log_level = 'DEBUG';\nExplanation: This statement will delete all rows in the 'logs' table where the log level column has the value 'DEBUG'."
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "data-types-murach": {
      "id": "data-types-murach",
      "title": "MySQL Data Types",
      "definition": "MySQL data types are specific formats used to store different kinds of data in a database table. Understanding and using the correct data type is crucial for efficient data storage and retrieval.",
      "difficulty": "beginner",
      "estimatedReadTime": 1,
      "pageReferences": [
        193,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        210,
        211,
        212
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p193:c1",
            "murachs-mysql-3rd-edition:p194:c1",
            "murachs-mysql-3rd-edition:p195:c1",
            "murachs-mysql-3rd-edition:p196:c1",
            "murachs-mysql-3rd-edition:p197:c1"
          ],
          "text": "MySQL data types are specific formats used to store different kinds of data in a database table. Understanding and using the correct data type is crucial for efficient data storage and retrieval."
        },
        "explanation": {
          "chunkIds": [],
          "text": "Data types in MySQL determine how data is stored and manipulated within a database. Common data types include INT for integers, VARCHAR for variable-length strings, DATE for dates, and FLOAT for floating-point numbers. Choosing the right data type ensures that data is stored efficiently and accurately. For example, using an INT instead of a VARCHAR for numerical data can save space and improve query performance."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p198:c1",
            "murachs-mysql-3rd-edition:p199:c1",
            "murachs-mysql-3rd-edition:p200:c1",
            "murachs-mysql-3rd-edition:p201:c1",
            "murachs-mysql-3rd-edition:p202:c1",
            "murachs-mysql-3rd-edition:p203:c1",
            "murachs-mysql-3rd-edition:p204:c1",
            "murachs-mysql-3rd-edition:p205:c1",
            "murachs-mysql-3rd-edition:p206:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- Define a TABLE with appropriate data types CREATE TABLE products ( product_id INT PRIMARY KEY, product_name VARCHAR(100), price FLOAT );",
              "explanation": "This example demonstrates how to create a table with columns of different data types. The product_id is an integer, product_name is a variable-length string, and price is a floating-point number.",
              "validation_note": "SQL auto-fixed: "
            },
            {
              "title": "Practical Example",
              "code": "-- INSERT data into the products TABLE INSERT INTO products (product_id, product_name, price) VALUES (1, 'Laptop', 999.99);",
              "explanation": "This practical example shows how to insert data into a table using the correct data types for each column.",
              "validation_note": "SQL auto-fixed: "
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p207:c1",
            "murachs-mysql-3rd-edition:p208:c1",
            "murachs-mysql-3rd-edition:p209:c1"
          ],
          "items": [
            {
              "mistake": "Using VARCHAR for numeric data",
              "incorrect_code": "-- Incorrect usage CREATE TABLE products ( product_id INT PRIMARY KEY, product_name VARCHAR(100), price VARCHAR(10) );",
              "correct_code": "-- Correct usage CREATE TABLE products ( product_id INT PRIMARY KEY, product_name VARCHAR(100), price FLOAT );",
              "explanation": "Using VARCHAR for numeric data can lead to issues with sorting and calculations. Always use the appropriate numeric data type like INT or FLOAT."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Create a table called 'employees' with columns: employee_id (INT), first_name (VARCHAR), last_name (VARCHAR), hire_date (DATE), salary (FLOAT). Insert one row of data into the table.",
            "solution": "-- Create and insert data into employees table\nCREATE TABLE employees (\n  employee_id INT PRIMARY KEY,\n  first_name VARCHAR(50),\n  last_name VARCHAR(50),\n  hire_date DATE,\n  salary FLOAT\n);\nINSERT INTO employees (employee_id, first_name, last_name, hire_date, salary) VALUES (1, 'John', 'Doe', '2020-06-15', 75000.00);"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "mysql-functions": {
      "id": "mysql-functions",
      "title": "MySQL Functions",
      "definition": "MySQL functions are pre-defined routines that perform specific operations on data. They help simplify complex queries and make your database more efficient.",
      "difficulty": "intermediate",
      "estimatedReadTime": 1,
      "pageReferences": [
        217,
        218,
        219,
        220,
        221,
        222,
        223,
        224,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238,
        239,
        240
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p217:c1",
            "murachs-mysql-3rd-edition:p218:c1",
            "murachs-mysql-3rd-edition:p219:c1",
            "murachs-mysql-3rd-edition:p220:c1",
            "murachs-mysql-3rd-edition:p221:c1"
          ],
          "text": "MySQL functions are pre-defined routines that perform specific operations on data. They help simplify complex queries and make your database more efficient."
        },
        "explanation": {
          "chunkIds": [],
          "text": "MySQL functions are essential for performing calculations, manipulating text, and handling dates and times directly within SQL queries without needing to write additional programming code. These functions can be grouped into several categories: arithmetic, string, date and time, and aggregate functions. Understanding how to use these functions correctly is crucial for writing efficient and powerful SQL queries."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p222:c1",
            "murachs-mysql-3rd-edition:p223:c1",
            "murachs-mysql-3rd-edition:p224:c1",
            "murachs-mysql-3rd-edition:p225:c1",
            "murachs-mysql-3rd-edition:p226:c1",
            "murachs-mysql-3rd-edition:p227:c1",
            "murachs-mysql-3rd-edition:p228:c1",
            "murachs-mysql-3rd-edition:p229:c1",
            "murachs-mysql-3rd-edition:p230:c1",
            "murachs-mysql-3rd-edition:p231:c1",
            "murachs-mysql-3rd-edition:p232:c1"
          ],
          "items": [
            {
              "title": "Basic Usage of an Aggregate Function",
              "code": "-- Calculate the total amount invoiced for each account\nSELECT account_number, SUM(line_item_amount) AS total_amount FROM Invoice_Line_Items GROUP BY account_number;",
              "explanation": "This example demonstrates how to use the SUM function to calculate the total line item amount for each account number. The results are grouped by account number."
            },
            {
              "title": "Practical Example: Using a String Function",
              "code": "-- Concatenate vendor name and account description\nSELECT CONCAT(vendor_name, ' - ', account_description) AS vendor_info FROM Vendors JOIN Invoice_Line_Items ON Vendors.account_number = Invoice_Line_Items.account_number;",
              "explanation": "This practical example shows how to use the CONCAT function to combine vendor name and account description into a single column. It joins two tables based on account number."
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p233:c1",
            "murachs-mysql-3rd-edition:p234:c1",
            "murachs-mysql-3rd-edition:p235:c1",
            "murachs-mysql-3rd-edition:p236:c1"
          ],
          "items": [
            {
              "mistake": "Incorrectly using aggregate functions without grouping",
              "incorrect_code": "-- This will cause an error\nSELECT SUM(line_item_amount) FROM Invoice_Line_Items;",
              "correct_code": "-- Correct usage with GROUP BY\nSELECT account_number, SUM(line_item_amount) AS total_amount FROM Invoice_Line_Items GROUP BY account_number;",
              "explanation": "Aggregates like SUM and AVG require a GROUP BY clause to operate on each group of rows. Failing to include it will result in an error."
            },
            {
              "mistake": "Forgetting to use parentheses with functions",
              "incorrect_code": "-- This will cause an error\nSELECT SUBSTRING(vendor_name, 1, 3) vendor_name FROM Vendors;",
              "correct_code": "-- Correct usage with parentheses\nSELECT SUBSTRING(vendor_name, 1, 3) AS vendor_name FROM Vendors;",
              "explanation": "Parentheses are necessary to define the arguments for functions. Forgetting them can lead to syntax errors."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Write a query that calculates the average invoice total for each quarter of 2018.",
            "solution": "-- Calculate average invoice total per quarter\nSELECT QUARTER(invoice_date) AS quarter, AVG(invoice_total) AS avg_total FROM Invoices WHERE YEAR(invoice_date) = 2018 GROUP BY quarter;"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "string-functions": {
      "id": "string-functions",
      "title": "String Functions",
      "definition": "String functions are built-in SQL commands used to manipulate and process character data within a database. They help in extracting specific parts of strings, converting their case, removing spaces, and more. Understanding string functions is crucial for data cleaning, formatting, and analysis.",
      "difficulty": "beginner",
      "estimatedReadTime": 1,
      "pageReferences": [
        218,
        219,
        220,
        221,
        222,
        223,
        224,
        225,
        226,
        227,
        228
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p218:c1",
            "murachs-mysql-3rd-edition:p219:c1",
            "murachs-mysql-3rd-edition:p220:c1"
          ],
          "text": "String functions are built-in SQL commands used to manipulate and process character data within a database. They help in extracting specific parts of strings, converting their case, removing spaces, and more. Understanding string functions is crucial for data cleaning, formatting, and analysis."
        },
        "explanation": {
          "chunkIds": [],
          "text": "String functions are essential tools in SQL that allow you to work with text data effectively. These functions can be used to perform various operations such as extracting substrings, replacing characters, converting case, trimming spaces, and more. By mastering string functions, you can enhance the quality of your data and make it easier to analyze and manipulate."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p221:c1",
            "murachs-mysql-3rd-edition:p222:c1",
            "murachs-mysql-3rd-edition:p223:c1",
            "murachs-mysql-3rd-edition:p224:c1",
            "murachs-mysql-3rd-edition:p225:c1",
            "murachs-mysql-3rd-edition:p226:c1",
            "murachs-mysql-3rd-edition:p227:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- Extract the first 5 characters FROM a string SELECT SUBSTRING(column_name, 1, 5) FROM table_name;",
              "explanation": "This example demonstrates how to use the `SUBSTRING` function to extract the first 5 characters from a column in a table.",
              "validation_note": "SQL auto-fixed: "
            },
            {
              "title": "Practical Example",
              "code": "-- Convert all text in a column to uppercase\nSELECT UPPER(column_name) FROM table_name;",
              "explanation": "This practical example shows how to use the `UPPER` function to convert all text in a specific column to uppercase."
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p228:c1"
          ],
          "items": [
            {
              "mistake": "Using incorrect function parameters",
              "incorrect_code": "-- Incorrect parameter usage\nSELECT SUBSTRING(column_name, 10, -5) FROM table_name;",
              "correct_code": "-- Correct parameter usage\nSELECT SUBSTRING(column_name, 10, 5) FROM table_name;",
              "explanation": "This mistake occurs when the parameters for a string function are incorrect. Always ensure that the start position and length are correctly specified."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Write a SQL query to extract the last name from a full name stored in a column named `full_name`.",
            "solution": "-- Correct solution\nSELECT SUBSTRING(full_name, CHARINDEX(' ', full_name) + 1) AS last_name FROM table_name;"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "date-functions": {
      "id": "date-functions",
      "title": "Date and Time Functions",
      "definition": "Date and Time Functions are built-in SQL functions that allow you to manipulate and extract information from date and time data types.",
      "difficulty": "intermediate",
      "estimatedReadTime": 1,
      "pageReferences": [
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p228:c1",
            "murachs-mysql-3rd-edition:p229:c1",
            "murachs-mysql-3rd-edition:p230:c1"
          ],
          "text": "Date and Time Functions are built-in SQL functions that allow you to manipulate and extract information from date and time data types."
        },
        "explanation": {
          "chunkIds": [],
          "text": "These functions are essential for performing operations on dates and times in your database. They help you filter, sort, and analyze data based on specific time-related criteria. For example, you might want to find all records from a particular month or year, calculate the age of users, or determine if an event has passed. By using date and time functions, you can make your queries more powerful and flexible."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p231:c1",
            "murachs-mysql-3rd-edition:p232:c1",
            "murachs-mysql-3rd-edition:p233:c1",
            "murachs-mysql-3rd-edition:p234:c1",
            "murachs-mysql-3rd-edition:p235:c1",
            "murachs-mysql-3rd-edition:p236:c1",
            "murachs-mysql-3rd-edition:p237:c1"
          ],
          "items": [
            {
              "title": "Extracting Year from a Date",
              "code": "SELECT EXTRACT(YEAR FROM order_date) AS year FROM orders;",
              "explanation": "This example demonstrates how to extract the year from an 'order_date' column in the 'orders' table. The result will be a list of years.",
              "validation_note": "SQL auto-fixed: "
            },
            {
              "title": "Adding Days to a Date",
              "code": "SELECT DATE_ADD(order_date, INTERVAL 7 DAY) AS next_week FROM orders;",
              "explanation": "This example shows how to add 7 days to each 'order_date' in the 'orders' table. The result will be a list of dates one week after each original order date."
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p238:c1"
          ],
          "items": [
            {
              "mistake": "Using incorrect function names",
              "incorrect_code": "SELECT EXTRACT(YEAR FROM order_date) AS year FROM orders;",
              "correct_code": "SELECT YEAR(order_date) AS year FROM orders;",
              "explanation": "The correct function name is 'YEAR', not 'EXTRACT' with the argument 'YEAR'. Always refer to the SQL documentation for the right function names."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Write a query that selects all records from the 'employees' table where the employee's hire date was in the year 2015.",
            "solution": "SELECT * FROM employees WHERE YEAR(hire_date) = 2015;"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "aggregate-functions-murach": {
      "id": "aggregate-functions-murach",
      "title": "Aggregate Functions",
      "definition": "Aggregate functions are used to perform calculations on a set of values and return a single value. They are essential for summarizing data and performing complex queries.",
      "difficulty": "beginner",
      "estimatedReadTime": 1,
      "pageReferences": [
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250,
        251,
        252,
        253,
        254,
        255,
        256,
        257,
        258,
        259,
        260
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p241:c1",
            "murachs-mysql-3rd-edition:p242:c1",
            "murachs-mysql-3rd-edition:p243:c1",
            "murachs-mysql-3rd-edition:p244:c1"
          ],
          "text": "Aggregate functions are used to perform calculations on a set of values and return a single value. They are essential for summarizing data and performing complex queries."
        },
        "explanation": {
          "chunkIds": [],
          "text": "Aggregate functions solve problems like calculating total sales, average prices, or maximum/minimum values in a dataset. Hereâ€™s how they work:\n1. **SUM**: Adds up all the values in a column.\n2. **AVG**: Calculates the average of a set of values.\n3. **MAX** and **MIN**: Find the highest and lowest values, respectively.\n4. **COUNT**: Counts the number of rows that match a specified condition.\nThese functions are used in conjunction with GROUP BY to summarize data at different levels (e.g., by state, by product category).\nWhen to use them? Whenever you need to get a single value from a set of values, such as total revenue for each quarter or average temperature per city."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p245:c1",
            "murachs-mysql-3rd-edition:p246:c1",
            "murachs-mysql-3rd-edition:p247:c1",
            "murachs-mysql-3rd-edition:p248:c1",
            "murachs-mysql-3rd-edition:p249:c1",
            "murachs-mysql-3rd-edition:p250:c1",
            "murachs-mysql-3rd-edition:p251:c1",
            "murachs-mysql-3rd-edition:p252:c1",
            "murachs-mysql-3rd-edition:p253:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- Calculate total sales per state\nSELECT vendor_state, SUM(invoice_total) AS total_sales FROM vendors v JOIN invoices i ON v.vendor_id = i.vendor_id GROUP BY vendor_state;",
              "explanation": "This example calculates the total sales for each state by summing up the invoice totals and grouping the results by vendor state."
            },
            {
              "title": "Practical Example",
              "code": "-- Find the average price of products in each category\nSELECT product_category, AVG(price) AS avg_price FROM products GROUP BY product_category;",
              "explanation": "This practical example calculates the average price of products within each category by grouping the data and using the AVG function."
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p254:c1",
            "murachs-mysql-3rd-edition:p255:c1",
            "murachs-mysql-3rd-edition:p256:c1",
            "murachs-mysql-3rd-edition:p257:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting to use GROUP BY",
              "incorrect_code": "-- Incorrect query\nSELECT vendor_state, SUM(invoice_total) AS total_sales FROM vendors v JOIN invoices i ON v.vendor_id = i.vendor_id;",
              "correct_code": "-- Correct query with GROUP BY\nSELECT vendor_state, SUM(invoice_total) AS total_sales FROM vendors v JOIN invoices i ON v.vendor_id = i.vendor_id GROUP BY vendor_state;",
              "explanation": "This mistake happens when students try to use an aggregate function without grouping the data. Always ensure you include GROUP BY when using aggregate functions."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Calculate the total number of orders per month for each year from a sales table.",
            "solution": "SELECT YEAR(order_date) AS order_year, MONTH(order_date) AS order_month, COUNT(*) AS total_orders FROM sales GROUP BY order_year, order_month ORDER BY order_year, order_month;"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "group-by-murach": {
      "id": "group-by-murach",
      "title": "GROUP BY Clause",
      "definition": "The GROUP BY clause is used to group rows that have the same values in specified columns into summary rows.",
      "difficulty": "intermediate",
      "estimatedReadTime": 1,
      "pageReferences": [
        253,
        254,
        255,
        256,
        257,
        258,
        259,
        260,
        261,
        262,
        263,
        264,
        265,
        266,
        267,
        268
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p253:c1",
            "murachs-mysql-3rd-edition:p254:c1",
            "murachs-mysql-3rd-edition:p255:c1",
            "murachs-mysql-3rd-edition:p256:c1"
          ],
          "text": "The GROUP BY clause is used to group rows that have the same values in specified columns into summary rows."
        },
        "explanation": {
          "chunkIds": [],
          "text": "The GROUP BY clause is essential for performing aggregate functions like SUM, AVG, COUNT, MAX, and MIN on grouped data. It works by dividing the table's rows into groups based on one or more columns. Each group can then be processed separately to compute aggregated values. This is particularly useful when you need to analyze data in a summarized form, such as calculating total sales per product category."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p257:c1",
            "murachs-mysql-3rd-edition:p258:c1",
            "murachs-mysql-3rd-edition:p259:c1",
            "murachs-mysql-3rd-edition:p260:c1",
            "murachs-mysql-3rd-edition:p261:c1",
            "murachs-mysql-3rd-edition:p262:c1",
            "murachs-mysql-3rd-edition:p263:c1",
            "murachs-mysql-3rd-edition:p264:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "SELECT category, SUM(sales) AS total_sales\nFROM products\nGROUP BY category;",
              "explanation": "This example groups the 'products' table by the 'category' column and calculates the total sales for each category."
            },
            {
              "title": "Practical Example",
              "code": "SELECT department, AVG(salary) AS avg_salary\nFROM employees\nGROUP BY department;",
              "explanation": "This practical example groups the 'employees' table by the 'department' column and calculates the average salary for each department."
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p265:c1",
            "murachs-mysql-3rd-edition:p266:c1",
            "murachs-mysql-3rd-edition:p267:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting to include non-aggregated columns in GROUP BY",
              "incorrect_code": "SELECT category, SUM(sales)\nFROM products;",
              "correct_code": "SELECT category, SUM(sales) AS total_sales\nFROM products\nGROUP BY category;",
              "explanation": "This mistake occurs when you try to select a column that is not aggregated without including it in the GROUP BY clause. It results in an error because MySQL doesn't know how to group rows for non-aggregated columns."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Create a query that groups employees by their department and calculates the total number of employees in each department.",
            "solution": "SELECT department, COUNT(*) AS employee_count\nFROM employees\nGROUP BY department;",
            "explanation": "This solution correctly groups the 'employees' table by the 'department' column and counts the number of employees in each department using the COUNT function."
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "having-murach": {
      "id": "having-murach",
      "title": "HAVING Clause",
      "definition": "The HAVING clause is used to filter groups of rows based on a condition after an aggregation has been applied. It's similar to WHERE but operates on aggregated data.",
      "difficulty": "intermediate",
      "estimatedReadTime": 1,
      "pageReferences": [
        265,
        266,
        267,
        268,
        269,
        270,
        271,
        272,
        273,
        274,
        275,
        276
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p265:c1",
            "murachs-mysql-3rd-edition:p266:c1",
            "murachs-mysql-3rd-edition:p267:c1",
            "murachs-mysql-3rd-edition:p268:c1"
          ],
          "text": "The HAVING clause is used to filter groups of rows based on a condition after an aggregation has been applied. It's similar to WHERE but operates on aggregated data."
        },
        "explanation": {
          "chunkIds": [],
          "text": "Imagine you have a dataset of sales transactions and you want to find out which products had total sales greater than $10,000. The HAVING clause allows you to specify this condition on the aggregated data (total sales). Here's how it works:\n1. GROUP BY is used to group rows that have the same values in specified columns.\n2. Aggregation functions like SUM(), COUNT(), AVG() are applied to each group.\n3. The HAVING clause then filters these groups based on a condition."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p269:c1",
            "murachs-mysql-3rd-edition:p270:c1",
            "murachs-mysql-3rd-edition:p271:c1",
            "murachs-mysql-3rd-edition:p272:c1",
            "murachs-mysql-3rd-edition:p273:c1",
            "murachs-mysql-3rd-edition:p274:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "SELECT product_id, SUM(sales_amount) as total_sales\nFROM sales\nGROUP BY product_id\nHAVING total_sales > 10000;",
              "explanation": "This query groups sales by product and filters out products with total sales less than or equal to $10,000."
            },
            {
              "title": "Practical Example",
              "code": "SELECT department_id, AVG(salary) as avg_salary\nFROM employees\nGROUP BY department_id\nHAVING avg_salary > 5000;",
              "explanation": "This practical example finds departments where the average salary is more than $5,000."
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p275:c1",
            "murachs-mysql-3rd-edition:p276:c1"
          ],
          "items": [
            {
              "mistake": "Using WHERE instead of HAVING",
              "incorrect_code": "SELECT product_id, SUM(sales_amount) as total_sales\nFROM sales\nWHERE total_sales > 10000;",
              "correct_code": "SELECT product_id, SUM(sales_amount) as total_sales\nFROM sales\ngroup BY product_id\nHAVING total_sales > 10000;",
              "explanation": "Remember, HAVING is for filtering groups after aggregation. WHERE filters rows before grouping."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Find the departments with more than 5 employees and list their IDs along with the number of employees in each department.",
            "solution": "SELECT department_id, COUNT(employee_id) as employee_count\nFROM employees\ngroup BY department_id\nHAVING employee_count > 5;"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "subqueries-murach": {
      "id": "subqueries-murach",
      "title": "Subqueries",
      "definition": "A subquery is a query nested within another query. It allows you to perform complex data retrieval operations by breaking down the task into smaller parts.",
      "difficulty": "intermediate",
      "estimatedReadTime": 1,
      "pageReferences": [
        277,
        278,
        279,
        280,
        281,
        282,
        283,
        284,
        285,
        286,
        287,
        288,
        289,
        290,
        291,
        292,
        293,
        294,
        295,
        296
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p277:c1",
            "murachs-mysql-3rd-edition:p278:c1",
            "murachs-mysql-3rd-edition:p279:c1",
            "murachs-mysql-3rd-edition:p280:c1",
            "murachs-mysql-3rd-edition:p281:c1"
          ],
          "text": "A subquery is a query nested within another query. It allows you to perform complex data retrieval operations by breaking down the task into smaller parts."
        },
        "explanation": {
          "chunkIds": [],
          "text": "Subqueries are incredibly useful for performing more advanced data analysis and manipulation. They allow you to filter, sort, or aggregate data based on results from other queries. For example, if you want to find all employees who earn more than the average salary, you can use a subquery to calculate the average salary first and then compare it with individual employee salaries."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p282:c1",
            "murachs-mysql-3rd-edition:p283:c1",
            "murachs-mysql-3rd-edition:p284:c1",
            "murachs-mysql-3rd-edition:p285:c1",
            "murachs-mysql-3rd-edition:p286:c1",
            "murachs-mysql-3rd-edition:p287:c1",
            "murachs-mysql-3rd-edition:p288:c1",
            "murachs-mysql-3rd-edition:p289:c1",
            "murachs-mysql-3rd-edition:p290:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- Find employees earning more than the average salary SELECT name, salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);",
              "explanation": "This example demonstrates how a subquery can be used in the WHERE clause to filter data based on results from another query.",
              "validation_note": "SQL auto-fixed: "
            },
            {
              "title": "Practical Example",
              "code": "-- Find products with stock less than 10 units SELECT product_name, stock FROM products WHERE stock < (SELECT MIN(stock) FROM products GROUP BY category HAVING COUNT(*) > 5);",
              "explanation": "This practical example shows how subqueries can be used to filter data based on aggregated results from another query.",
              "validation_note": "SQL auto-fixed: "
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p291:c1",
            "murachs-mysql-3rd-edition:p292:c1",
            "murachs-mysql-3rd-edition:p293:c1",
            "murachs-mysql-3rd-edition:p294:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting to use parentheses around the subquery.",
              "incorrect_code": "-- Incorrect: SELECT name, salary FROM employees WHERE salary > AVG(salary);",
              "correct_code": "-- Correct: SELECT name, salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);",
              "explanation": "Subqueries must be enclosed in parentheses to ensure they are evaluated correctly."
            },
            {
              "mistake": "Using the wrong comparison operator.",
              "incorrect_code": "-- Incorrect: SELECT name, salary FROM employees WHERE salary < (SELECT MAX(salary) FROM employees);",
              "correct_code": "-- Correct: SELECT name, salary FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);",
              "explanation": "It's crucial to use the correct comparison operator based on the desired outcome."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Write a query that finds all customers who have made more than one purchase.",
            "solution": "-- Solution: SELECT customer_id FROM purchases GROUP BY customer_id HAVING COUNT(*) > 1;"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "correlated-subquery-murach": {
      "id": "correlated-subquery-murach",
      "title": "Correlated Subqueries",
      "definition": "Correlated subqueries are a type of SQL query where a subquery is nested within another query and references data from the outer query.",
      "difficulty": "advanced",
      "estimatedReadTime": 1,
      "pageReferences": [
        289,
        290,
        291,
        292,
        293,
        294,
        295,
        296,
        297,
        298,
        299,
        300
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p289:c1",
            "murachs-mysql-3rd-edition:p290:c1",
            "murachs-mysql-3rd-edition:p291:c1",
            "murachs-mysql-3rd-edition:p292:c1"
          ],
          "text": "Correlated subqueries are a type of SQL query where a subquery is nested within another query and references data from the outer query."
        },
        "explanation": {
          "chunkIds": [],
          "text": "Correlated subqueries are essential when you need to compare or filter data based on values that exist in another part of your query. They allow you to perform complex operations by leveraging data from both the main query and the subquery. This is particularly useful when dealing with conditions that depend on specific rows within a dataset."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p293:c1",
            "murachs-mysql-3rd-edition:p294:c1",
            "murachs-mysql-3rd-edition:p295:c1",
            "murachs-mysql-3rd-edition:p296:c1",
            "murachs-mysql-3rd-edition:p297:c1",
            "murachs-mysql-3rd-edition:p298:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- Find employees who earn more than the average salary in their department SELECT employee_id, first_name, last_name, salary FROM employees e1 WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.department_id = e1.department_id);",
              "explanation": "This example demonstrates how a correlated subquery is used to compare each employee's salary against the average salary in their department.",
              "validation_note": "SQL auto-fixed: "
            },
            {
              "title": "Practical Example",
              "code": "-- Find customers who have made more than one purchase SELECT customer_id, first_name, last_name FROM customers c1 WHERE (SELECT COUNT(*) FROM orders o WHERE o.customer_id = c1.customer_id) > 1;",
              "explanation": "This practical example shows how a correlated subquery can be used to identify customers who have made multiple purchases.",
              "validation_note": "SQL auto-fixed: "
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p299:c1",
            "murachs-mysql-3rd-edition:p300:c1"
          ],
          "items": [
            {
              "mistake": "Incorrectly using an outer join instead of a correlated subquery",
              "incorrect_code": "-- Incorrect use of outer join\nSELECT e.employee_id, e.first_name, e.last_name, AVG(o.order_amount) AS avg_order_amount\nFROM employees e\nLEFT JOIN orders o ON e.employee_id = o.employee_id\nGROUP BY e.employee_id;",
              "correct_code": "-- Correct use of correlated subquery SELECT employee_id, first_name, last_name, (SELECT AVG(order_amount) FROM orders WHERE employee_id = e.employee_id) AS avg_order_amount FROM employees e;",
              "explanation": "This mistake occurs when a student tries to solve a problem with an outer join instead of a correlated subquery. The correct approach uses a correlated subquery to calculate the average order amount for each employee."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Write a query that finds products which have been ordered more than 10 times.",
            "solution": "-- Solution using correlated subquery\nSELECT product_id, product_name\nFROM products p\nWHERE (SELECT COUNT(*) FROM orders_items oi WHERE oi.product_id = p.product_id) > 10;"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "unions": {
      "id": "unions",
      "title": "UNION and UNION ALL",
      "definition": "UNION and UNION ALL are SQL operators used to combine the results of two or more SELECT statements into a single result set.",
      "difficulty": "intermediate",
      "estimatedReadTime": 1,
      "pageReferences": [
        301,
        302,
        303,
        304,
        305,
        306,
        307,
        308,
        309,
        310,
        311,
        312
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p301:c1",
            "murachs-mysql-3rd-edition:p302:c1",
            "murachs-mysql-3rd-edition:p303:c1"
          ],
          "text": "UNION and UNION ALL are SQL operators used to combine the results of two or more SELECT statements into a single result set."
        },
        "explanation": {
          "chunkIds": [],
          "text": "UNION combines the results of multiple SELECT queries, removing duplicate rows from the final output. UNION ALL includes all rows from each query, including duplicates. This is useful when you need to aggregate data from different tables or conditions without manually merging them in your application code."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p304:c1",
            "murachs-mysql-3rd-edition:p305:c1",
            "murachs-mysql-3rd-edition:p306:c1",
            "murachs-mysql-3rd-edition:p307:c1",
            "murachs-mysql-3rd-edition:p308:c1",
            "murachs-mysql-3rd-edition:p309:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- Combining results FROM two tables SELECT name FROM employees UNION SELECT name FROM contractors;",
              "explanation": "This example combines the names of all employees and contractors into one list, removing any duplicate names.",
              "validation_note": "SQL auto-fixed: "
            },
            {
              "title": "Practical Example",
              "code": "-- Finding customers who have made both online AND in-store purchases SELECT customer_id FROM online_orders UNION SELECT customer_id FROM store_sales;",
              "explanation": "This practical example identifies customers who have purchased items both online and in-store, using UNION to combine the results from two different tables.",
              "validation_note": "SQL auto-fixed: "
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p310:c1",
            "murachs-mysql-3rd-edition:p311:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting to use ORDER BY at the end of all UNION statements",
              "incorrect_code": "-- Incorrect usage SELECT name FROM employees UNION SELECT name FROM contractors;",
              "correct_code": "-- Correct usage SELECT name FROM employees UNION SELECT name FROM contractors ORDER BY name;",
              "explanation": "Students often forget to include ORDER BY at the end, which can lead to errors or unexpected results. Always ensure it's placed correctly if sorting is needed."
            },
            {
              "mistake": "Using UNION when UNION ALL would suffice",
              "incorrect_code": "-- Incorrect usage SELECT name FROM employees UNION SELECT name FROM contractors;",
              "correct_code": "-- Correct usage SELECT name FROM employees UNION ALL SELECT name FROM contractors;",
              "explanation": "Using UNION when duplicates are not a concern can lead to unnecessary performance overhead. Always choose the most efficient option based on your needs."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Write a SQL query using UNION to combine results from two tables, one containing customer names and email addresses, and another containing customer names and phone numbers.",
            "solution": "-- Solution\nSELECT name, email FROM customers_email\nUNION\nSELECT name, phone_number FROM customers_phone;\n-- This query combines the names and contact information (email or phone) of all customers into a single result set."
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "create-table-murach": {
      "id": "create-table-murach",
      "title": "Creating Tables",
      "definition": "Analytic functions are special SQL functions that perform calculations across a set of rows related to the current row. They help in ranking, filtering, and summarizing data within partitions.",
      "difficulty": "beginner",
      "estimatedReadTime": 1,
      "pageReferences": [
        317,
        318,
        319,
        320,
        321,
        322,
        323,
        324,
        325,
        326,
        327,
        328,
        329,
        330,
        331,
        332,
        333,
        334
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p317:c1",
            "murachs-mysql-3rd-edition:p318:c1",
            "murachs-mysql-3rd-edition:p319:c1",
            "murachs-mysql-3rd-edition:p320:c1"
          ],
          "text": "Analytic functions are special SQL functions that perform calculations across a set of rows related to the current row. They help in ranking, filtering, and summarizing data within partitions."
        },
        "explanation": {
          "chunkIds": [],
          "text": "Analytic functions are essential for complex data analysis tasks where you need to compare values across multiple rows. These functions operate on a window of rows defined by the PARTITION BY clause and sort them using the ORDER BY clause. Key analytic functions include FIRST_VALUE, LAST_VALUE, NTH_VALUE, LEAD, LAG, PERCENT_RANK, and CUME_DIST. They are particularly useful in financial analysis, sales reporting, and any scenario where you need to analyze trends or compare data points over time."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p321:c1",
            "murachs-mysql-3rd-edition:p322:c1",
            "murachs-mysql-3rd-edition:p323:c1",
            "murachs-mysql-3rd-edition:p324:c1",
            "murachs-mysql-3rd-edition:p325:c1",
            "murachs-mysql-3rd-edition:p326:c1",
            "murachs-mysql-3rd-edition:p327:c1",
            "murachs-mysql-3rd-edition:p328:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- Get the highest sales for each year\nSELECT sales_year, rep_first_name, rep_last_name, sales_total,\nFIRST_VALUE(sales_total) OVER (PARTITION BY sales_year ORDER BY sales_total DESC) AS highest_sales\nFROM sales_totals JOIN sales_reps ON sales_totals.rep_id = sales_reps.rep_id;",
              "explanation": "This example uses FIRST_VALUE to find the highest sales for each year by comparing sales totals within each partition defined by sales_year."
            },
            {
              "title": "Practical Example",
              "code": "-- Calculate sales change FROM previous year SELECT rep_id, sales_year, sales_total, LAG(sales_total) OVER (PARTITION BY rep_id ORDER BY sales_year) AS last_sales, sales_total - LAG(sales_total) OVER (PARTITION BY rep_id ORDER BY sales_year) AS change FROM sales_totals;",
              "explanation": "This practical example calculates the change in sales from the previous year for each sales representative.",
              "validation_note": "SQL auto-fixed: "
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p329:c1",
            "murachs-mysql-3rd-edition:p330:c1",
            "murachs-mysql-3rd-edition:p331:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting to use PARTITION BY",
              "incorrect_code": "-- Incorrect query without partitioning\nSELECT rep_id, sales_year, sales_total,\nLAG(sales_total) OVER (ORDER BY sales_year) AS last_sales\nFROM sales_totals;",
              "correct_code": "-- Correct query with partitioning\nSELECT rep_id, sales_year, sales_total,\nLAG(sales_total) OVER (PARTITION BY rep_id ORDER BY sales_year) AS last_sales\nFROM sales_totals;",
              "explanation": "This mistake occurs when students try to use LAG or other analytic functions without specifying how the data should be partitioned. Always include PARTITION BY to ensure correct results."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Write a query that uses the CUME_DIST function to find the cumulative distribution of sales totals for each year in the Sales_Totals table.",
            "solution": "-- Solution using CUME_DIST\nSELECT sales_year, rep_id, sales_total,\nCUME_DIST() OVER (PARTITION BY sales_year ORDER BY sales_total) AS cume_dist\nFROM sales_totals;"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "alter-table-murach": {
      "id": "alter-table-murach",
      "title": "Altering Tables",
      "definition": "Altering tables is the process of changing an existing database table's structure, such as adding new columns, removing existing ones, or modifying column properties.",
      "difficulty": "intermediate",
      "estimatedReadTime": 1,
      "pageReferences": [
        333,
        334,
        335,
        336,
        337,
        338,
        339,
        340,
        341,
        342,
        343,
        344
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p333:c1",
            "murachs-mysql-3rd-edition:p334:c1",
            "murachs-mysql-3rd-edition:p335:c1"
          ],
          "text": "Altering tables is the process of changing an existing database table's structure, such as adding new columns, removing existing ones, or modifying column properties."
        },
        "explanation": {
          "chunkIds": [],
          "text": "When designing a database, it's crucial to have well-structured tables that accurately represent your data. However, real-world requirements often change, necessitating alterations to these tables. Altering tables allows you to make these necessary changes without losing the integrity of your existing data. Hereâ€™s how it works and when to use it."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p336:c1",
            "murachs-mysql-3rd-edition:p337:c1",
            "murachs-mysql-3rd-edition:p338:c1",
            "murachs-mysql-3rd-edition:p339:c1",
            "murachs-mysql-3rd-edition:p340:c1",
            "murachs-mysql-3rd-edition:p341:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- Adding a new column ALTER TABLE Vendors ADD COLUMN vendor_email VARCHAR(255);",
              "explanation": "This example demonstrates how to add a new column 'vendor_email' to the 'Vendors' table. It's useful when you need to store additional contact information for vendors.",
              "validation_note": "SQL auto-fixed: "
            },
            {
              "title": "Practical Example",
              "code": "-- Modifying an existing column ALTER TABLE Invoices MODIFY COLUMN invoice_total DECIMAL(10, 2);",
              "explanation": "This practical example shows how to change the data type of 'invoice_total' in the 'Invoices' table to a more precise decimal format. This is important for financial calculations.",
              "validation_note": "SQL auto-fixed: "
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p342:c1",
            "murachs-mysql-3rd-edition:p343:c1"
          ],
          "items": [
            {
              "mistake": "Using the wrong command",
              "incorrect_code": "-- Incorrect command ALTER TABLE Vendors ADD vendor_phone;",
              "correct_code": "-- Correct command ALTER TABLE Vendors ADD COLUMN vendor_phone VARCHAR(15);",
              "explanation": "The mistake here is not specifying the data type for the new column. Always include the correct data type to ensure the column functions properly."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Create a practical question that tests understanding of this concept",
            "solution": "Provide a clear solution with explanation"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "constraints-murach": {
      "id": "constraints-murach",
      "title": "Constraints",
      "definition": "Constraints are rules that ensure data integrity and consistency within a database. They prevent invalid or duplicate data from being entered into tables.",
      "difficulty": "intermediate",
      "estimatedReadTime": 1,
      "pageReferences": [
        345,
        346,
        347,
        348,
        349,
        350,
        351,
        352,
        353,
        354,
        355,
        356,
        357,
        358
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p345:c1",
            "murachs-mysql-3rd-edition:p346:c1",
            "murachs-mysql-3rd-edition:p347:c1",
            "murachs-mysql-3rd-edition:p348:c1"
          ],
          "text": "Constraints are rules that ensure data integrity and consistency within a database. They prevent invalid or duplicate data from being entered into tables."
        },
        "explanation": {
          "chunkIds": [],
          "text": "Constraints are essential for maintaining the accuracy and reliability of your database. Think of them as quality control checks that ensure only valid data is stored. There are several types of constraints, including NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK, and DEFAULT. Each serves a specific purpose in ensuring data consistency and completeness."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p349:c1",
            "murachs-mysql-3rd-edition:p350:c1",
            "murachs-mysql-3rd-edition:p351:c1",
            "murachs-mysql-3rd-edition:p352:c1",
            "murachs-mysql-3rd-edition:p353:c1",
            "murachs-mysql-3rd-edition:p354:c1",
            "murachs-mysql-3rd-edition:p355:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- Adding a NOT NULL constraint to a column ALTER TABLE employees ADD COLUMN email VARCHAR(255) NOT NULL;",
              "explanation": "This example adds a NOT NULL constraint to the 'email' column, ensuring that every employee must have an email address.",
              "validation_note": "SQL auto-fixed: "
            },
            {
              "title": "Practical Example",
              "code": "-- Adding a UNIQUE constraint to ensure no duplicate emails ALTER TABLE employees ADD CONSTRAINT unique_email UNIQUE (email);",
              "explanation": "This practical example ensures that all email addresses in the 'employees' table are unique, preventing duplicates.",
              "validation_note": "SQL auto-fixed: "
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p356:c1",
            "murachs-mysql-3rd-edition:p357:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting to specify NOT NULL when creating a column",
              "incorrect_code": "-- Incorrect SQL CREATE TABLE employees (id INT);",
              "correct_code": "-- Correct SQL CREATE TABLE employees (id INT NOT NULL);",
              "explanation": "This mistake can lead to null values in columns where they should not be allowed. Always specify NOT NULL when it's appropriate."
            },
            {
              "mistake": "Using UNIQUE instead of PRIMARY KEY for a column that needs to uniquely identify rows",
              "incorrect_code": "-- Incorrect SQL CREATE TABLE employees (id INT UNIQUE);",
              "correct_code": "-- Correct SQL CREATE TABLE employees (id INT PRIMARY KEY);",
              "explanation": "PRIMARY KEY is more than just UNIQUE; it also ensures NOT NULL. Use PRIMARY KEY when you need a column to uniquely identify rows."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Create a table named 'products' with columns for product_id (primary key), name, and price. Ensure that the 'name' column cannot be null and must be unique.",
            "solution": "-- Solution\nCREATE TABLE products (\n    product_id INT PRIMARY KEY,\n    name VARCHAR(255) NOT NULL UNIQUE,\n    price DECIMAL(10, 2)\n);"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "views-murach": {
      "id": "views-murach",
      "title": "Views",
      "definition": "A view is like a virtual table that presents data from one or more tables based on a query. It allows you to simplify complex queries and provide a consistent interface for accessing data.",
      "difficulty": "intermediate",
      "estimatedReadTime": 1,
      "pageReferences": [
        381,
        382,
        383,
        384,
        385,
        386,
        387,
        388,
        389,
        390,
        391,
        392,
        393,
        394,
        395,
        396
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p381:c1",
            "murachs-mysql-3rd-edition:p382:c1",
            "murachs-mysql-3rd-edition:p383:c1",
            "murachs-mysql-3rd-edition:p384:c1"
          ],
          "text": "A view is like a virtual table that presents data from one or more tables based on a query. It allows you to simplify complex queries and provide a consistent interface for accessing data."
        },
        "explanation": {
          "chunkIds": [],
          "text": "Views are incredibly useful in database management because they help simplify complex queries and provide a consistent interface for accessing data. Imagine you have a large database with many tables, and you frequently need to retrieve specific information from these tables. Instead of writing the same complex query every time, you can create a view that encapsulates this query. This way, whenever you need the data, you simply query the view, which makes your work much easier and reduces the chance for errors."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p385:c1",
            "murachs-mysql-3rd-edition:p386:c1",
            "murachs-mysql-3rd-edition:p387:c1",
            "murachs-mysql-3rd-edition:p388:c1",
            "murachs-mysql-3rd-edition:p389:c1",
            "murachs-mysql-3rd-edition:p390:c1",
            "murachs-mysql-3rd-edition:p391:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- Create a view that shows all invoices with their total amounts\nCREATE VIEW invoice_totals AS SELECT invoice_id, invoice_number, invoice_total FROM invoices;",
              "explanation": "This example creates a view named `invoice_totals` that combines the `invoice_id`, `invoice_number`, and `invoice_total` columns from the `invoices` table. Now, whenever you need to see all invoices with their total amounts, you can simply query the `invoice_totals` view instead of writing the full query each time."
            },
            {
              "title": "Practical Example",
              "code": "-- Query the view to get a list of all invoices with their total amounts\nSELECT * FROM invoice_totals;",
              "explanation": "This practical example shows how you can use the `invoice_totals` view to retrieve data. By querying the view, you don't need to remember or write the complex query that combines the necessary columns from the `invoices` table."
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p392:c1",
            "murachs-mysql-3rd-edition:p393:c1",
            "murachs-mysql-3rd-edition:p394:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting to include the AS keyword when creating a view",
              "incorrect_code": "-- Incorrect syntax\nCREATE VIEW invoice_totals SELECT invoice_id, invoice_number, invoice_total FROM invoices;",
              "correct_code": "-- Correct syntax\nCREATE VIEW invoice_totals AS SELECT invoice_id, invoice_number, invoice_total FROM invoices;",
              "explanation": "This mistake happens when someone tries to create a view without using the `AS` keyword. The correct syntax is to use `CREATE VIEW view_name AS SELECT columns FROM table;`. Remembering to include the `AS` keyword is crucial for defining the view correctly."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Create a view that shows all customers who have made at least one purchase. The view should include the customer's name and email.",
            "solution": "-- Create a view named 'active_customers'\nCREATE VIEW active_customers AS SELECT c.customer_name, c.email FROM customers c JOIN orders o ON c.customer_id = o.customer_id;",
            "explanation": "This practice question asks you to create a view that combines data from the `customers` and `orders` tables. The view should include only those customers who have made at least one purchase. By creating this view, you can easily retrieve information about active customers without having to write complex joins every time."
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "stored-procedures": {
      "id": "stored-procedures",
      "title": "Stored Procedures",
      "definition": "A stored procedure is a precompiled sequence of SQL statements that are stored in the database and can be executed by name.",
      "difficulty": "intermediate",
      "estimatedReadTime": 1,
      "pageReferences": [
        401,
        402,
        403,
        404,
        405,
        406,
        407,
        408,
        409,
        410,
        411,
        412,
        413,
        414,
        415,
        416,
        417,
        418
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p401:c1",
            "murachs-mysql-3rd-edition:p402:c1",
            "murachs-mysql-3rd-edition:p403:c1",
            "murachs-mysql-3rd-edition:p404:c1"
          ],
          "text": "A stored procedure is a precompiled sequence of SQL statements that are stored in the database and can be executed by name."
        },
        "explanation": {
          "chunkIds": [],
          "text": "Stored procedures are essential for several reasons:\n1. **Performance**: They reduce network traffic as they execute on the server side.\n2. **Security**: They limit what users can do, enhancing security by restricting access to underlying data.\n3. **Reusability**: Procedures can be called multiple times without rewriting code.\n4. **Maintenance**: Changes made in a procedure affect all calls to it, simplifying updates."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p405:c1",
            "murachs-mysql-3rd-edition:p406:c1",
            "murachs-mysql-3rd-edition:p407:c1",
            "murachs-mysql-3rd-edition:p408:c1",
            "murachs-mysql-3rd-edition:p409:c1",
            "murachs-mysql-3rd-edition:p410:c1",
            "murachs-mysql-3rd-edition:p411:c1",
            "murachs-mysql-3rd-edition:p412:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- Create a simple stored procedure\nCREATE PROCEDURE GetEmployeeDetails (@empID INT)\nAS\nBEGIN\nSELECT * FROM Employees WHERE EmployeeID = @empID;\nEND;",
              "explanation": "This example demonstrates how to create a stored procedure that retrieves details of an employee based on their ID."
            },
            {
              "title": "Practical Example",
              "code": "-- Call the stored procedure EXEC GetEmployeeDetails 101;",
              "explanation": "This practical example shows how to execute the stored procedure created in the previous example.",
              "validation_note": "SQL auto-fixed: "
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p413:c1",
            "murachs-mysql-3rd-edition:p414:c1",
            "murachs-mysql-3rd-edition:p415:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting to declare parameters",
              "incorrect_code": "-- Incorrect: Missing parameter declaration\nCREATE PROCEDURE GetEmployeeDetails\nAS\nBEGIN\nSELECT * FROM Employees WHERE EmployeeID = @empID;\nEND;",
              "correct_code": "-- Correct: Declaring the parameter\nCREATE PROCEDURE GetEmployeeDetails (@empID INT)\nAS\nBEGIN\nSELECT * FROM Employees WHERE EmployeeID = @empID;\nEND;",
              "explanation": "This mistake occurs when creating a stored procedure without declaring parameters. Always ensure all necessary parameters are declared."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Create a stored procedure that updates the salary of an employee based on their ID.",
            "solution": "-- Solution: Create and execute the stored procedure\nCREATE PROCEDURE UpdateEmployeeSalary (@empID INT, @newSalary DECIMAL(10,2))\nAS\nBEGIN\nUPDATE Employees SET Salary = @newSalary WHERE EmployeeID = @empID;\nEND;\n-- Execute the procedure\nEXEC UpdateEmployeeSalary 101, 5000.00;"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "functions-murach": {
      "id": "functions-murach",
      "title": "Stored Functions",
      "definition": "A stored function is a precompiled block of SQL code that performs a specific task and returns a single value. It allows you to encapsulate complex logic and reuse it throughout your database applications.",
      "difficulty": "intermediate",
      "estimatedReadTime": 1,
      "pageReferences": [
        417,
        418,
        419,
        420,
        421,
        422,
        423,
        424,
        425,
        426,
        427,
        428
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p417:c1",
            "murachs-mysql-3rd-edition:p418:c1",
            "murachs-mysql-3rd-edition:p419:c1",
            "murachs-mysql-3rd-edition:p420:c1"
          ],
          "text": "A stored function is a precompiled block of SQL code that performs a specific task and returns a single value. It allows you to encapsulate complex logic and reuse it throughout your database applications."
        },
        "explanation": {
          "chunkIds": [],
          "text": "Stored functions are incredibly useful for performing calculations, data transformations, or any repetitive tasks within the database itself. They help in reducing network traffic by moving computation from the application layer to the database layer. Hereâ€™s how they work:\n\n1. **Creating a Stored Function**: You define a stored function using the `CREATE FUNCTION` statement. This involves specifying the function name, parameters (if any), and the SQL code that performs the task.\n2. **Calling a Stored Function**: Once created, you can call this function like any other SQL expression within your queries or procedures.\n3. **Benefits of Using Functions**: They improve performance by reducing the need to execute complex logic multiple times. They also enhance security by keeping sensitive business logic on the database server."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p421:c1",
            "murachs-mysql-3rd-edition:p422:c1",
            "murachs-mysql-3rd-edition:p423:c1",
            "murachs-mysql-3rd-edition:p424:c1",
            "murachs-mysql-3rd-edition:p425:c1",
            "murachs-mysql-3rd-edition:p426:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- CREATE a function to calculate the total price including tax CREATE FUNCTION CalculateTotal(price DECIMAL(10,2), tax_rate DECIMAL(5,2)) RETURNS DECIMAL(10,2) DETERMINISTIC BEGIN DECLARE total DECIMAL(10,2); SET total = price * (1 + tax_rate / 100); RETURN total; END;",
              "explanation": "This example shows how to create a function that calculates the total price including tax. The function takes two parameters: `price` and `tax_rate`, and returns the calculated total.",
              "validation_note": "SQL auto-fixed: "
            },
            {
              "title": "Practical Example",
              "code": "-- Use the function in a query\nSELECT product_name, CalculateTotal(price, 10) AS total_price FROM products;",
              "explanation": "This practical example demonstrates how to use the `CalculateTotal` function in a SQL query to get the total price including tax for each product."
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p427:c1",
            "murachs-mysql-3rd-edition:p428:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting to declare the return type",
              "incorrect_code": "-- Incorrect: Missing RETURN TYPE CREATE FUNCTION CalculateTotal(price DECIMAL(10,2), tax_rate DECIMAL(5,2)) BEGIN DECLARE total DECIMAL(10,2); SET total = price * (1 + tax_rate / 100); END;",
              "correct_code": "-- Correct: Declared RETURN TYPE CREATE FUNCTION CalculateTotal(price DECIMAL(10,2), tax_rate DECIMAL(5,2)) RETURNS DECIMAL(10,2) BEGIN DECLARE total DECIMAL(10,2); SET total = price * (1 + tax_rate / 100); RETURN total; END;",
              "explanation": "The function must declare its return type using the `RETURNS` keyword. Missing this will cause a syntax error."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Create a stored function that calculates the average salary for each department in the `employees` table.",
            "solution": "-- Solution\nCREATE FUNCTION AverageSalaryByDepartment(department_id INT)\nRETURNS DECIMAL(10,2)\nDETERMINISTIC\nBEGIN\n  DECLARE avg_salary DECIMAL(10,2);\n  SELECT AVG(salary) INTO avg_salary FROM employees WHERE department_id = department_id;\n  RETURN avg_salary;\nEND;"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "triggers": {
      "id": "triggers",
      "title": "Triggers",
      "definition": "A trigger is a special type of stored procedure that automatically executes when a specific event occurs on a table, such as INSERT, UPDATE, or DELETE. It helps maintain data integrity and enforce business rules directly within the database.",
      "difficulty": "advanced",
      "estimatedReadTime": 1,
      "pageReferences": [
        429,
        430,
        431,
        432,
        433,
        434,
        435,
        436,
        437,
        438,
        439,
        440
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p429:c1",
            "murachs-mysql-3rd-edition:p430:c1",
            "murachs-mysql-3rd-edition:p431:c1",
            "murachs-mysql-3rd-edition:p432:c1"
          ],
          "text": "A trigger is a special type of stored procedure that automatically executes when a specific event occurs on a table, such as INSERT, UPDATE, or DELETE. It helps maintain data integrity and enforce business rules directly within the database."
        },
        "explanation": {
          "chunkIds": [],
          "text": "Triggers are incredibly useful for maintaining the consistency and accuracy of your data without having to write complex application logic. They allow you to perform actions automatically whenever certain events happen on a table. For example, if you want to ensure that every time a new record is inserted into an 'orders' table, the total amount is calculated and stored in another column, you can create a trigger for this purpose."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p433:c1",
            "murachs-mysql-3rd-edition:p434:c1",
            "murachs-mysql-3rd-edition:p435:c1",
            "murachs-mysql-3rd-edition:p436:c1",
            "murachs-mysql-3rd-edition:p437:c1",
            "murachs-mysql-3rd-edition:p438:c1"
          ],
          "items": [
            {
              "title": "Basic Trigger Example",
              "code": "-- CREATE a trigger that updates the 'last_modified' column whenever any row in the 'employees' TABLE is updated. CREATE TRIGGER update_last_modified BEFORE UPDATE ON employees FOR EACH ROW BEGIN SET NEW.last_modified = NOW(); END;",
              "explanation": "This example shows how to create a trigger that automatically updates the 'last_modified' column with the current timestamp every time an employee record is updated.",
              "validation_note": "SQL auto-fixed: "
            },
            {
              "title": "Practical Example",
              "code": "-- CREATE a trigger that inserts a new row into an 'audit_log' TABLE whenever a new product is added to the 'products' TABLE. CREATE TRIGGER log_product_addition AFTER INSERT ON products FOR EACH ROW BEGIN INSERT INTO audit_log (action, product_id, action_date) VALUES ('Added', NEW.product_id, NOW()); END;",
              "explanation": "This practical example demonstrates how a trigger can be used to maintain an audit log of all changes made to the 'products' table.",
              "validation_note": "SQL auto-fixed: "
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p439:c1",
            "murachs-mysql-3rd-edition:p440:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting to specify the correct timing (BEFORE, AFTER) for the trigger.",
              "incorrect_code": "-- Incorrect trigger creation CREATE TRIGGER incorrect_trigger ON employees FOR EACH ROW BEGIN SET NEW.last_modified = NOW(); END;",
              "correct_code": "-- Correct trigger creation CREATE TRIGGER update_last_modified AFTER UPDATE ON employees FOR EACH ROW BEGIN SET NEW.last_modified = NOW(); END;",
              "explanation": "Triggers must specify when they should be executed (BEFORE or AFTER the event). Forgetting this can lead to unexpected behavior."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Create a trigger that automatically updates the 'total_amount' column in the 'orders' table whenever any row is updated.",
            "solution": "-- Solution\nCREATE TRIGGER update_total_amount\nBEFORE UPDATE ON orders\nFOR EACH ROW\nBEGIN\nSET NEW.total_amount = NEW.quantity * NEW.price;\nEND;"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "events": {
      "id": "events",
      "title": "Events",
      "definition": "Events are special types of triggers that automatically execute when a specific event occurs within a database. They help automate tasks and maintain data integrity without requiring manual intervention.",
      "difficulty": "advanced",
      "estimatedReadTime": 1,
      "pageReferences": [
        441,
        442,
        443,
        444,
        445,
        446,
        447,
        448,
        449,
        450,
        451,
        452
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p441:c1",
            "murachs-mysql-3rd-edition:p442:c1",
            "murachs-mysql-3rd-edition:p443:c1",
            "murachs-mysql-3rd-edition:p444:c1"
          ],
          "text": "Events are special types of triggers that automatically execute when a specific event occurs within a database. They help automate tasks and maintain data integrity without requiring manual intervention."
        },
        "explanation": {
          "chunkIds": [],
          "text": "Events are crucial for automating routine tasks in databases, such as backups, archiving old data, or sending notifications. Hereâ€™s how they work and when to use them:\n\n1. **What problem do events solve?** Events help automate repetitive tasks that would otherwise require manual intervention, saving time and reducing errors.\n\n2. **How do they work?** An event is defined with a schedule (like daily, weekly) and a SQL statement or stored procedure to execute. When the scheduled time arrives, the database runs the specified task automatically.\n\n3. **When to use them?** Use events for tasks that need to run at regular intervals, such as cleaning up old data, sending periodic reports, or performing backups.\n\n4. **Key things to remember:** Always test your event before deploying it in a production environment. Ensure the SQL statement is correct and wonâ€™t cause unintended side effects."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p445:c1",
            "murachs-mysql-3rd-edition:p446:c1",
            "murachs-mysql-3rd-edition:p447:c1",
            "murachs-mysql-3rd-edition:p448:c1",
            "murachs-mysql-3rd-edition:p449:c1",
            "murachs-mysql-3rd-edition:p450:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- Create a simple event to delete old records daily\nCREATE EVENT delete_old_records\nON SCHEDULE EVERY 1 DAY\nDO DELETE FROM old_data WHERE date < DATE_SUB(CURDATE(), INTERVAL 30 DAY);",
              "explanation": "This example creates an event that deletes records from the `old_data` table every day, keeping only the last 30 days of data."
            },
            {
              "title": "Practical Example",
              "code": "-- Schedule a weekly report generation CREATE EVENT generate_weekly_report ON SCHEDULE EVERY 1 WEEK STARTS '2024-01-01' DO CALL generate_report();",
              "explanation": "This practical example schedules a stored procedure `generate_report` to run every week starting from January 1, 2024.",
              "validation_note": "SQL auto-fixed: "
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p451:c1",
            "murachs-mysql-3rd-edition:p452:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting to test the event before deployment.",
              "incorrect_code": "-- Incorrectly scheduled event without testing\nCREATE EVENT delete_old_records\nON SCHEDULE EVERY 1 DAY\nDO DELETE FROM old_data WHERE date < DATE_SUB(CURDATE(), INTERVAL 30 DAY);",
              "correct_code": "-- Correctly scheduled and tested event\nCREATE EVENT delete_old_records\nON SCHEDULE EVERY 1 DAY\nDO BEGIN\n    -- Test the SQL statement first\n    SELECT * FROM old_data WHERE date < DATE_SUB(CURDATE(), INTERVAL 30 DAY);\n    DELETE FROM old_data WHERE date < DATE_SUB(CURDATE(), INTERVAL 30 DAY);\nEND;",
              "explanation": "Always test your event with a small subset of data before deploying it to ensure it works as expected."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Create an event that runs every Monday at 8 AM to update the status of all orders in the `orders` table to 'Processed'.",
            "solution": "-- Solution\nCREATE EVENT process_orders_daily\nON SCHEDULE EVERY 1 WEEK DAYOFWEEK = 2 STARTS '2024-01-07'\nDO UPDATE orders SET status = 'Processed';\n-- Explanation: This event updates the status of all orders to 'Processed' every Monday at 8 AM."
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "transactions-murach": {
      "id": "transactions-murach",
      "title": "Transactions",
      "definition": "Transactions are sequences of database operations that must either complete successfully together or fail as a whole. They ensure data integrity and consistency by preventing concurrent modifications from interfering with each other.",
      "difficulty": "intermediate",
      "estimatedReadTime": 1,
      "pageReferences": [
        457,
        458,
        459,
        460,
        461,
        462,
        463,
        464,
        465,
        466,
        467,
        468,
        469,
        470,
        471,
        472
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p457:c1",
            "murachs-mysql-3rd-edition:p458:c1",
            "murachs-mysql-3rd-edition:p459:c1",
            "murachs-mysql-3rd-edition:p460:c1"
          ],
          "text": "Transactions are sequences of database operations that must either complete successfully together or fail as a whole. They ensure data integrity and consistency by preventing concurrent modifications from interfering with each other."
        },
        "explanation": {
          "chunkIds": [],
          "text": "Transactions help solve concurrency problems in databases, ensuring that multiple users can access and modify the same data without causing conflicts. Hereâ€™s how they work:\n1. **Isolation**: Transactions are isolated from one another, meaning changes made during a transaction do not affect others until it is completed.\n2. **Atomicity**: Each transaction is treated as a single unit of work that either completes successfully or fails entirely.\n3. **Consistency**: A transaction must leave the database in a consistent state before and after its execution.\n4. **Durability**: Once a transaction is committed, its changes are permanent, even if the system crashes afterward.\n\nTransactions are crucial for maintaining data integrity in large systems with multiple users."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p461:c1",
            "murachs-mysql-3rd-edition:p462:c1",
            "murachs-mysql-3rd-edition:p463:c1",
            "murachs-mysql-3rd-edition:p464:c1",
            "murachs-mysql-3rd-edition:p465:c1",
            "murachs-mysql-3rd-edition:p466:c1",
            "murachs-mysql-3rd-edition:p467:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- Start a transaction BEGIN; UPDATE accounts SET balance = balance - 100 WHERE account_id = 1; UPDATE accounts SET balance = balance + 100 WHERE account_id = 2; COMMIT;",
              "explanation": "This example demonstrates how to start a transaction, perform two updates, and commit the changes. If any part of the transaction fails, it can be rolled back using ROLLBACK.",
              "validation_note": "SQL auto-fixed: "
            },
            {
              "title": "Practical Example",
              "code": "-- Transfer money between accounts BEGIN; UPDATE accounts SET balance = balance - 100 WHERE account_id = 1; UPDATE accounts SET balance = balance + 100 WHERE account_id = 2; COMMIT;",
              "explanation": "This practical example shows a real-world scenario where money is transferred between two accounts. The transaction ensures that both updates are successful or neither happens, maintaining the integrity of the financial data.",
              "validation_note": "SQL auto-fixed: "
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p468:c1",
            "murachs-mysql-3rd-edition:p469:c1",
            "murachs-mysql-3rd-edition:p470:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting to commit or rollback",
              "incorrect_code": "-- Incorrect: No commit OR rollback BEGIN; UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;",
              "correct_code": "-- Correct: Commit the transaction BEGIN; UPDATE accounts SET balance = balance - 100 WHERE account_id = 1; COMMIT;",
              "explanation": "Mistakes happen when a transaction is not properly committed or rolled back, leading to partial changes that can cause inconsistencies."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Write a SQL transaction to update the inventory of two products. If either product's stock goes below zero, roll back the transaction.",
            "solution": "-- Solution: Use a transaction with conditional logic\nBEGIN;\nUPDATE inventory SET stock = stock - 10 WHERE product_id = 1;\nUPDATE inventory SET stock = stock - 5 WHERE product_id = 2;\nIF (SELECT stock FROM inventory WHERE product_id = 1) < 0 OR (SELECT stock FROM inventory WHERE product_id = 2) < 0 THEN\n    ROLLBACK;\nELSE\n    COMMIT;\nEND IF;",
            "explanation": "This solution demonstrates how to use a transaction with conditional logic to ensure that the inventory update is only committed if both products have sufficient stock. If not, it rolls back the changes."
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "isolation-levels-murach": {
      "id": "isolation-levels-murach",
      "title": "Transaction Isolation Levels",
      "definition": "Transaction isolation levels determine how transactions interact with each other and with data changes made by other transactions. They ensure data consistency and prevent anomalies like dirty reads, non-repeatable reads, and phantom reads.",
      "difficulty": "advanced",
      "estimatedReadTime": 1,
      "pageReferences": [
        471,
        472,
        473,
        474,
        475,
        476,
        477,
        478,
        479,
        480,
        481,
        482
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p471:c1",
            "murachs-mysql-3rd-edition:p472:c1",
            "murachs-mysql-3rd-edition:p473:c1",
            "murachs-mysql-3rd-edition:p474:c1"
          ],
          "text": "Transaction isolation levels determine how transactions interact with each other and with data changes made by other transactions. They ensure data consistency and prevent anomalies like dirty reads, non-repeatable reads, and phantom reads."
        },
        "explanation": {
          "chunkIds": [],
          "text": "In a database system, multiple users can access the same data simultaneously, which can lead to conflicts if not managed properly. Transaction isolation levels help manage these conflicts by controlling how transactions see and modify data. The four main isolation levels are: READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, and SERIALIZABLE. Each level offers a different balance between performance and data consistency."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p475:c1",
            "murachs-mysql-3rd-edition:p476:c1",
            "murachs-mysql-3rd-edition:p477:c1",
            "murachs-mysql-3rd-edition:p478:c1",
            "murachs-mysql-3rd-edition:p479:c1",
            "murachs-mysql-3rd-edition:p480:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "-- Set transaction isolation level to REPEATABLE READ SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;",
              "explanation": "This example demonstrates how to set the transaction isolation level in SQL. Setting it to REPEATABLE READ ensures that a transaction sees the same data multiple times during its execution.",
              "validation_note": "SQL auto-fixed: "
            },
            {
              "title": "Practical Example",
              "code": "-- Start a transaction START TRANSACTION; -- UPDATE a record UPDATE employees SET salary = 5000 WHERE employee_id = 101; -- Commit the transaction COMMIT;",
              "explanation": "This practical example shows how to use transaction isolation levels in a real-world scenario. It starts a transaction, updates an employee's salary, and commits the changes.",
              "validation_note": "SQL auto-fixed: "
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p481:c1",
            "murachs-mysql-3rd-edition:p482:c1"
          ],
          "items": [
            {
              "mistake": "Not setting the isolation level",
              "incorrect_code": "-- No isolation level set\nSELECT * FROM employees;",
              "correct_code": "-- Set isolation level to READ COMMITTED\nSET TRANSACTION ISOLATION LEVEL READ COMMITTED;\n-- Then perform operations\nSELECT * FROM employees;",
              "explanation": "Failing to set an isolation level can lead to inconsistent data readings. Always ensure that the appropriate isolation level is set for your transactions."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Which isolation level provides the highest level of data consistency and prevents all types of anomalies?",
            "solution": "The SERIALIZABLE isolation level provides the highest level of data consistency and prevents all types of anomalies by ensuring that transactions are executed in a serialized manner. However, it can significantly impact performance."
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "user-management": {
      "id": "user-management",
      "title": "User Management",
      "definition": "A stored procedure or function is a precompiled block of SQL code that can be executed by its name. They help organize complex operations and make database interactions more efficient and secure.",
      "difficulty": "intermediate",
      "estimatedReadTime": 1,
      "pageReferences": [
        487,
        488,
        489,
        490,
        491,
        492,
        493,
        494,
        495,
        496,
        497,
        498,
        499,
        500,
        501,
        502
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p487:c1",
            "murachs-mysql-3rd-edition:p488:c1",
            "murachs-mysql-3rd-edition:p489:c1",
            "murachs-mysql-3rd-edition:p490:c1"
          ],
          "text": "A stored procedure or function is a precompiled block of SQL code that can be executed by its name. They help organize complex operations and make database interactions more efficient and secure."
        },
        "explanation": {
          "chunkIds": [],
          "text": "Stored procedures and functions are essential tools for managing and manipulating data in a database. They solve the problem of repetitive tasks by allowing you to write a set of instructions once and execute them multiple times. Hereâ€™s how they work:\n1. **Definition**: You define a stored procedure or function with a name, parameters (if any), and SQL code that performs specific operations.\n2. **Execution**: Once defined, you can call this procedure or function by its name, passing the required parameters if any. This execution is handled by the database server, which optimizes performance.\n3. **Usage**: They are particularly useful for tasks like data validation, complex calculations, and batch processing. For example, calculating a balance due based on invoice details.\n4. **Key Points**:\n   - **Determinism**: Functions must be deterministic or non-deterministic (default). Deterministic functions always return the same result for the same input, which is crucial for binary logging.\n   - **Security**: Stored procedures can enhance security by limiting what users can do directly on the database. They also help prevent SQL injection attacks.\n   - **Performance**: By precompiling and caching SQL code, stored procedures can improve performance compared to executing dynamic SQL statements repeatedly.\n   - **Maintenance**: Changes made in a single location (the procedure or function) affect all places where it is called, reducing the risk of errors."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p491:c1",
            "murachs-mysql-3rd-edition:p492:c1",
            "murachs-mysql-3rd-edition:p493:c1",
            "murachs-mysql-3rd-edition:p494:c1",
            "murachs-mysql-3rd-edition:p495:c1",
            "murachs-mysql-3rd-edition:p496:c1",
            "murachs-mysql-3rd-edition:p497:c1"
          ],
          "items": [
            {
              "title": "Basic Usage",
              "code": "DELIMITER //\nCREATE FUNCTION rand_int ()\nRETURNS INT\nNOT DETERMINISTIC\nNO SQL\nBEGIN\nRETURN ROUND (RAND () * 1000);\nEND//\nSELECT rand_int () AS random_number;",
              "explanation": "This example creates a function that returns a random integer between 0 and 1000. It then calls this function to get a random number."
            },
            {
              "title": "Practical Example",
              "code": "DELIMITER //\nCREATE FUNCTION get_balance_due (invoice_id_param INT)\nRETURNS DECIMAL(9,2)\nDETERMINISTIC READS SQL DATA\nBEGIN\nDECLARE balance_due_var DECIMAL(9,2);\nSELECT invoice_total - payment_total - credit_total INTO balance_due_var FROM invoices WHERE invoice_id = invoice_id_param;\nRETURN balance_due_var;\nEND//\nSELECT vendor_id, invoice_number, get_balance_due(invoice_id) AS balance_due FROM invoices WHERE vendor_id = 37;",
              "explanation": "This practical example creates a function to calculate the balance due for a given invoice ID. It then selects vendor ID, invoice number, and the calculated balance due from the invoices table where the vendor ID is 37."
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p498:c1",
            "murachs-mysql-3rd-edition:p499:c1",
            "murachs-mysql-3rd-edition:p500:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting to declare variables",
              "incorrect_code": "DELIMITER //\nCREATE FUNCTION get_balance_due (invoice_id_param INT)\nRETURNS DECIMAL(9,2)\nDETERMINISTIC READS SQL DATA\nBEGIN\nSELECT invoice_total - payment_total - credit_total INTO balance_due_var FROM invoices WHERE invoice_id = invoice_id_param;\nRETURN balance_due_var;\nEND//",
              "correct_code": "DELIMITER //\nCREATE FUNCTION get_balance_due (invoice_id_param INT)\nRETURNS DECIMAL(9,2)\nDETERMINISTIC READS SQL DATA\nBEGIN\nDECLARE balance_due_var DECIMAL(9,2);\nSELECT invoice_total - payment_total - credit_total INTO balance_due_var FROM invoices WHERE invoice_id = invoice_id_param;\nRETURN balance_due_var;\nEND//",
              "explanation": "This mistake occurs when you forget to declare the variable before using it. Always declare all variables used in your function."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "Create a stored procedure that calculates the total sales for each product category.",
            "solution": "DELIMITER //\nCREATE PROCEDURE get_total_sales_by_category()\nBEGIN\nSELECT category, SUM(sales) AS total_sales FROM products GROUP BY category;\nEND//\ncall get_total_sales_by_category();"
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    },
    "backup-restore": {
      "id": "backup-restore",
      "title": "Backup and Restore",
      "definition": "Backup and restore are processes used to save copies of databases and recover them when needed. This ensures data safety and availability.",
      "difficulty": "intermediate",
      "estimatedReadTime": 1,
      "pageReferences": [
        505,
        506,
        507,
        508,
        509,
        510,
        511,
        512,
        513,
        514,
        515,
        516,
        517,
        518,
        519,
        520
      ],
      "sections": {
        "definition": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p505:c1",
            "murachs-mysql-3rd-edition:p506:c1",
            "murachs-mysql-3rd-edition:p507:c1",
            "murachs-mysql-3rd-edition:p508:c1"
          ],
          "text": "Backup and restore are processes used to save copies of databases and recover them when needed. This ensures data safety and availability."
        },
        "explanation": {
          "chunkIds": [],
          "text": "Database backups are crucial for protecting against data loss due to hardware failures, software errors, or malicious attacks. A backup creates a copy of the database at a specific point in time. When a restore is performed, this backup is used to recreate the database state. This process helps maintain business continuity and data integrity."
        },
        "examples": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p509:c1",
            "murachs-mysql-3rd-edition:p510:c1",
            "murachs-mysql-3rd-edition:p511:c1",
            "murachs-mysql-3rd-edition:p512:c1",
            "murachs-mysql-3rd-edition:p513:c1",
            "murachs-mysql-3rd-edition:p514:c1",
            "murachs-mysql-3rd-edition:p515:c1"
          ],
          "items": [
            {
              "title": "Basic Backup",
              "code": "-- SQL command to CREATE a backup of the 'mydatabase' database mysqldump -u username -p mydatabase > mydatabase_backup.sql;",
              "explanation": "This example demonstrates how to use the mysqldump utility to create a backup of a database. The backup file is saved in the current directory.",
              "validation_note": "SQL auto-fixed: "
            },
            {
              "title": "Practical Example",
              "code": "-- SQL command to restore 'mydatabase' from a backup\nmysql -u username -p mydatabase < mydatabase_backup.sql;",
              "explanation": "This example shows how to restore a database using the mysqldump utility. The database is restored from the previously created backup file."
            }
          ]
        },
        "commonMistakes": {
          "chunkIds": [
            "murachs-mysql-3rd-edition:p516:c1",
            "murachs-mysql-3rd-edition:p517:c1"
          ],
          "items": [
            {
              "mistake": "Forgetting to include the database name in the backup command",
              "incorrect_code": "-- Incorrect backup command mysqldump -u username -p > mydatabase_backup.sql;",
              "correct_code": "-- Correct backup command mysqldump -u username -p mydatabase > mydatabase_backup.sql;",
              "explanation": "This mistake can lead to an incomplete backup. Always specify the database name in the mysqldump command."
            }
          ]
        },
        "practice": {
          "chunkIds": [],
          "questions": {
            "question": "How would you create a backup of a database named 'sales' using mysqldump?",
            "solution": "The correct SQL command is: mysqldump -u username -p sales > sales_backup.sql. This command will prompt for the password and then create a backup of the 'sales' database, saving it as 'sales_backup.sql'."
          }
        }
      },
      "relatedConcepts": [],
      "tags": []
    }
  }
}